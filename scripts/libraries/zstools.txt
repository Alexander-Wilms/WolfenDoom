/*
 * Copyright (c) 2020 Talon1024, Username-N00b-is-not-available, AFADoomer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class ZScriptTools
{
	// Calculate the time it will take for a projectile to hit a moving target,
	// assuming constant velocities for both the projectile and target.
	//
	// Why calculate impact time rather than the position? It is more flexible,
	// because then you can calculate impact position like this:
	// ImpactPos = TargetPos + TargetVel * ImpactTime;
	//
	// Based on math and code from https://indyandyjones.wordpress.com/2010/04/08/intercepting-a-target-with-projectile/
	// Very important excerpt from that particular blog post:
	// Squaring and multiplication of vectors against vectors amounts to taking
	// the dot product
	static double GetInterceptTime(Vector3 ToTarget, Vector3 TargetVel, double MissileSpeed)
	{
		// Get the terms of the quadratic equation.
		// Taking the dot product of a vector with itself is the same as
		// getting its squared length.
		double a = (TargetVel dot TargetVel) - MissileSpeed * MissileSpeed;
		double b = 2 * TargetVel dot ToTarget;
		double c = ToTarget dot ToTarget;
		double radicand = (b * b) - (4 * a * c);
		if (radicand < 0)
		{
			// Cannot calculate intercept time
			if (developer >= 1)
			{
				Console.Printf("Cannot calculate intercept time!");
			}
			return 0.0;
		}
		// This aims ahead of the target. If the other root was used,
		// the calculated impact point would be behind the target.
		double time = (-b - sqrt(radicand)) / (2 * a);
		return time;
	}

	// Takes projectile origin and target position rather than the vector
	// between the two positions.
	static double GetInterceptTime4(Vector3 ProjPos, Vector3 TargetPos, Vector3 TargetVel, double MissileSpeed)
	{
		// LevelLocals.Vec3Diff accounts for portals
		Vector3 ToTarget = LevelLocals.Vec3Diff(ProjPos, TargetPos); // TargetPos - ProjPos
		return ZScriptTools.GetInterceptTime(ToTarget, TargetVel, MissileSpeed);
	}

	// Is a particular bit set in this integer?
	static bool BitIsSet(int number, int bitIndex)
	{
		return !!(number & (1 << bitIndex));
	}

	// Set a bit in this integer
	static int BitSet(int number, int bitIndex)
	{
		return number | (1 << bitIndex);
	}

	// Unset a bit in this integer
	static int BitUnset(int number, int bitIndex)
	{
		return number & (~(1 << bitIndex));
	}

	// Get Z velocity for a falling projectile such that it hits a target at
	// the given distance and height.
	//
	// time is the 2D distance between the shooter and target, divided by the
	// speed. In other words, the amount of time (in tics) the projectile would
	// take to reach the target if it didn't fall.
	//
	// gravity is the amount the Z velocity decreases each tic.
	//
	// height is the height difference between the shooter and target.
	static double ArcZVel(double time, double gravity, double height = 0)
	{
		gravity *= .5; // I have no idea why I needed to do this, but I did...
		double badd = height / time;
		double b = time * gravity + badd;
		return -gravity + b;
	}

	// Like "clamp", but for angles rather than plain numbers
	static double ClampAngle(double angle, double min, double max)
	{
		min = Actor.Normalize180(min);
		max = Actor.Normalize180(max);
		double maxdiff = Actor.deltaangle(angle, max);
		double mindiff = Actor.deltaangle(min, angle);
		// Invert clamp
		if (maxdiff < 0 && mindiff < 0)
		{
			if (mindiff < maxdiff)
			{
				return max;
			}
			else
			{
				return min;
			}
		}
		if (maxdiff < 0)
		{
			return max;
		}
		else if (mindiff < 0)
		{
			return min;
		}
		return Actor.Normalize180(angle);
	}

	// Convert int to Roman numerals...  Just because.
	// Reference https://www.hanshq.net/roman-numerals.html for algorithm used
	static clearscope String ToRomanNumerals(int input)
	{
		static const string numerals[] = { "I", "V", "X", "L", "C", "D", "M" };
		int d = 0;
		String roman = "";

		while (input > 0)
		{
			int num = input % 10;

			if (num % 5 < 4)
			{
				for (int i = num % 5; i > 0; i--)
				{
					roman = numerals[d] .. roman;
				}
			}
			if (num >= 4 && num <= 8) { roman = numerals[d + 1] .. roman; }
			if (num == 9) { roman = numerals[d + 2] .. roman; }
			if (num % 5 == 4) { roman = numerals[d] .. roman; }

			input /= 10;
			d += 2;
		}

		return roman;
	}

	// Takes a string of font names, separated by '|'.  Checks to see if the 'check' string can be
	// printed by each listed font; if one is able to print the string, that font is returned.
	//
	//  This will check to see if Chalkboard can print all of the characters listed, and if not, it
	//  will move on to Typewriter and test it the same way, and so on:
	//
	//  	ZScriptTools.GetViableFont("Chalkboard|Typewriter|handwriting_neat|handwriting_institute|chickn24", "0123456789%/ :");
	//
	//  Fallback if none of the passed fonts can print the string is to return SmallFont.
	static clearscope Font GetViableFont(String fntname, String check = "")
	{
		// Splot the string to create an array of font names
		Array<String> fonts;
		fntname.Split(fonts, "|");

		// Iterate through the array of fonts until you find one that can print all of the characters
		for (int f = 0; f < fonts.Size(); f++)
		{
			Font fnt = Font.GetFont(fonts[f]);
			if (fnt && fnt.CanPrint(check)) { return fnt; }
		}

		return SmallFont; // If all else fails, fall back to SmallFont
	}
}
