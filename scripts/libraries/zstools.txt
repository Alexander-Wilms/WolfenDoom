/*
 * Copyright (c) 2020 Talon1024, Username-N00b-is-not-available
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class ZScriptTools
{
	// Calculate the time it will take for a projectile to hit a moving target,
	// assuming constant velocities for both the projectile and target.
	//
	// Why calculate impact time rather than the position? It is more flexible,
	// because then you can calculate impact position like this:
	// ImpactPos = TargetPos + TargetVel * ImpactTime;
	//
	// Based on math and code from https://indyandyjones.wordpress.com/2010/04/08/intercepting-a-target-with-projectile/
	// Very important excerpt from that particular blog post:
	// Squaring and multiplication of vectors against vectors amounts to taking
	// the dot product
	static double GetInterceptTime(Vector3 ToTarget, Vector3 TargetVel, double MissileSpeed)
	{
		// Get the terms of the quadratic equation.
		// Taking the dot product of a vector with itself is the same as
		// getting its squared length.
		double a = (TargetVel dot TargetVel) - MissileSpeed * MissileSpeed;
		double b = 2 * TargetVel dot ToTarget;
		double c = ToTarget dot ToTarget;
		double radicand = (b * b) - (4 * a * c);
		if (radicand < 0)
		{
			// Cannot calculate intercept time
			if (developer >= 1)
			{
				Console.Printf("Cannot calculate intercept time!");
			}
			return 0.0;
		}
		// This aims ahead of the target. If the other root was used,
		// the calculated impact point would be behind the target.
		double time = (-b - sqrt(radicand)) / (2 * a);
		return time;
	}

	// Takes projectile origin and target position rather than the vector
	// between the two positions.
	static double GetInterceptTime4(Vector3 ProjPos, Vector3 TargetPos, Vector3 TargetVel, double MissileSpeed)
	{
		// LevelLocals.Vec3Diff accounts for portals
		Vector3 ToTarget = LevelLocals.Vec3Diff(ProjPos, TargetPos); // TargetPos - ProjPos
		return ZScriptTools.GetInterceptTime(ToTarget, TargetVel, MissileSpeed);
	}

	// Is a particular bit set in this integer?
	static bool BitIsSet(int number, int bitIndex)
	{
		return !!(number & (1 << bitIndex));
	}

	// Set a bit in this integer
	static int BitSet(int number, int bitIndex)
	{
		return number | (1 << bitIndex);
	}

	// Unset a bit in this integer
	static int BitUnset(int number, int bitIndex)
	{
		return number & (~(1 << bitIndex));
	}

	// Get Z velocity for an arcing projectile, where:
	// time is the 2D distance between the shooter and target, divided by the speed
	// gravity is the amount the Z velocity decreases each tic
	// height is the height difference between the shooter and target
	static double ArcZVel(double time, double gravity, double height = 0)
	{
		gravity *= .5; // I have no idea why I needed to do this, but I did...
		double badd = height / time;
		double b = time * gravity + badd;
		return -gravity + b;
	}

	// Like "clamp", but for angles rather than plain numbers
	static double ClampAngle(double angle, double min, double max)
	{
		angle = Actor.Normalize180(angle);
		min = Actor.Normalize180(min);
		max = Actor.Normalize180(max);
		double maxdiff = Actor.deltaangle(angle, max);
		double mindiff = -Actor.deltaangle(angle, min);
		// Invert clamp
		if (maxdiff < 0 && mindiff < 0)
		{
			if (mindiff < maxdiff)
			{
				return max;
			}
			else
			{
				return min;
			}
		}
		if (maxdiff < 0)
		{
			return max;
		}
		else if (mindiff < 0)
		{
			return min;
		}
		return angle;
	}
}
