/*
 * Copyright (c) 2018-2020 AFADoomer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class BoAMenu : GenericMenu
{
	static void SetMenu(Actor caller, Name mnu, int param = 0)
	{
		if (players[consoleplayer].mo != caller) { return; }

		Menu.SetMenu(mnu, param);
	}
}

class CombinationSafe : BoAMenu
{
	TextureID spinner, spinnerfront, spinnerback, background, turn;
	Vector2 location, size, bgsize, screendimensions;
	double scale, bgscale;
	int angle, destangle, dir, olddir, set, count;
	int keyactive;
	int combo[3], solution[3];
	int speed, steps;
	Safe s;
	int initial;
	int ticcount;
	BrokenLines hintlines;
	double hintx, hinty, hintlineheight;

	override void Init(Menu parent)
	{
		Super.Init(parent);

		spinner = TexMan.CheckForTexture("DIAL", TexMan.Type_Any);
		spinnerfront = TexMan.CheckForTexture("DIAL_F", TexMan.Type_Any);
		spinnerback = TexMan.CheckForTexture("DIAL_B", TexMan.Type_Any);
		background = TexMan.CheckForTexture("SAFEBKG", TexMan.Type_Any);
		turn = TexMan.CheckForTexture("DIAL_DIR", TexMan.Type_Any);

		location = (427, 240);
		[location, screendimensions] = Screen.VirtualToRealCoords(location, (screen.GetWidth(), screen.GetHeight()), (640, 480));

		size = TexMan.GetScaledSize(spinner);
		bgsize = TexMan.GetScaledSize(background);
		scale = 0.4 * screen.GetHeight() / size.y;
		bgscale = scale * 1.75;

		s = Safe(players[consoleplayer].ConversationNPC);

		steps = 24;
		speed = (360 / steps) / 6;

		if (s && !s.special)
		{
			solution[0] = s.args[1];
			solution[1] = s.args[2];
			solution[2] = s.args[3];
		}

		// If no combination set, use the object's coordinates to derive a combination
		if (solution[0] == 0 && solution[1] == 0 && solution[2] == 0)
		{
			// Default to setting a pseudo-random combo...  If you flag the actor wth STANDSTILL, it will stay unlocked
			if (s && !s.bStandStill)
			{
				solution[0] = int(abs(s.pos.x % steps));
				solution[1] = int(abs(s.pos.y % steps));
				solution[2] = int(abs(s.pos.z % steps));
			}
		}

		if (developer) { console.printf("%i %i %i", solution[0], solution[1], solution[2]); }

		DontDim = true;
		menuactive = OnNoPause;

		destangle = 360 * 3;
		initial = 1;

		String hintmessage = StringTable.Localize("SAFEHINT", false);
		hintlines = SmallFont.BreakLines(hintmessage, 240);

		hintx = 320;
		hintlineheight = SmallFont.GetHeight();
		hinty = 470 - hintlineheight * (hintlines.Count() - 0.5);
	}

	override void Drawer()
	{
		if (solution[0] != 0 || solution[1] != 0 || solution[2] != 0)
		{
			screen.Dim(0x000000, 0.2, 0, 0, screen.GetWidth(), screen.GetHeight());

			if (background)
			{
				screen.DrawTexture(background, false, location.x - bgsize.x * bgscale / 9.2, location.y, DTA_DestWidth, int(bgsize.x * bgscale), DTA_DestHeight, int(bgsize.y * bgscale), DTA_CenterOffset, true);
			}

			if (spinnerback)
			{
				screen.DrawTexture(spinnerback, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true);
			}

			if (spinner)
			{
				let shape = ShapeUtil.MakeSquare();
				ShapeUtil.MoveSquare(shape, size * scale, location, 360 - angle);
				Screen.DrawShape(spinner, false, shape);
			}

			if (spinnerfront)
			{
				screen.DrawTexture(spinnerfront, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true);
			}

			if (ticcount > 0 && initial > 0)
			{
				double alpha;

				if (initial == 1 && ticcount <= 175)
				{
					// Print hint message (duplicates ACS "HintMessage" script, but with handling for multiple lines)
					if (ticcount == 10) { S_StartSound("menu/change", CHAN_7, CHANF_UI | CHANF_NOSTOP, 1.0); }

					if (ticcount >= 105)
					{
						alpha = 0.5 + sin(((ticcount - 70) * 360 / 70 - 90) / 2);
					}
					else if (ticcount >= 35 && ticcount < 105)
					{
						alpha = 1.0;
					}
					else
					{
						alpha = 0.5 + sin((ticcount * 360 / 70 - 90) / 2);
					}

					for (int i = 0; i < hintlines.Count(); i++)
					{
						screen.DrawText(SmallFont, Font.CR_GRAY, hintx - hintlines.StringWidth(i) / 2, hinty + hintlineheight * i, hintlines.StringAt(i), DTA_VirtualWidth, 640, DTA_VirtualHeight, 480, DTA_Alpha, alpha);
					}
				}
				
				if (ticcount > 35)
				{
					alpha = 0.5 * (0.5 + sin(((ticcount - 35) * 720 / 70 - 90) / 2));
					if (ticcount < 105 || ticcount > 175)
					{
						screen.DrawTexture(turn, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true, DTA_Alpha, alpha);
					}
					else if (ticcount < 245)
					{
						screen.DrawTexture(turn, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true, DTA_FlipX, true, DTA_Alpha, alpha);
					}
				}
			}
		}
	}

	override void Ticker()
	{
		if (solution[0] == 0 && solution[1] == 0 && solution[2] == 0)
		{
			TryOpen();
			Close();

			return;
		}

		if (initial)
		{
			ticcount++;

			if (ticcount >= 245)
			{
				ticcount = 0;
				initial++;

				if (initial > 2) { initial = 0; }
			}
		}

		if (keyactive > 0)
		{
			keyactive--;
			ticcount = 0;
			initial = 0;
		}

		if (keyactive)
		{
			S_StartSound("safe/dial", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.65);

			if (destangle > angle)
			{
				angle += speed * 2;
				dir = 1;

				if (angle > 360)
				{
					angle -= 360;
					count = max(0, count -1);
				}
			}
			else if (destangle < angle)
			{
				angle -= speed * 2;
				dir = -1;

				if (angle < 0)
				{
					angle += 360;
				}
			}
		}
		else
		{
			destangle = angle - (angle % speed);
			angle = destangle;
		}
// if (set < 3) { console.printf("%i >>> %i", (angle / (360 / steps)) % steps, solution[set]); }
		if (olddir && olddir != dir && set < 3)
		{
			combo[set] = (angle / (360 / steps)) % steps;

			set++;
			count++;
		}

		olddir = dir;

		if (set > 0 && count <= 0)
		{
			DoReset();
		}

		Super.Ticker();
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		switch (mkey)
		{
			case MKEY_Up:
			case MKEY_Down:
			case MKEY_Back:
				Close();
				return true;
			case MKEY_Enter:
				// Attempt Open
				if (set == 2)
				{
					combo[2] = angle / (360 / steps);
					TryOpen();
				}

				if (set > 2)
				{
					TryOpen();
				}

				return true;
			case MKEY_Right:
				// Turn Right
				keyactive = 5;
				destangle = angle - speed * 4;

				return true;
			case MKEY_Left:
				// Turn Left
				keyactive = 5;
				destangle = angle + speed * 4;

				return true;
			default:
				return false;
		}
	}

	override bool MouseEvent(int type, int x, int y)
	{
		return false;
	}

	override bool OnUIEvent(UIEvent ev)
	{
		// Intercept key presses to see if we're pressing the strafe controls or use, 
		// and redirect those to call the correct left/right/open movement menu event code.

		if (ev.Type == UIEvent.Type_KeyDown || ev.Type == UIEVent.Type_Char)
		{
			CheckControl(ev, "+moveleft", MKEY_Left);
			CheckControl(ev, "+moveright", MKEY_Right);
			CheckControl(ev, "+use", MKEY_Enter);
			CheckControl(ev, "+forward", MKEY_Up);
			CheckControl(ev, "+back", MKEY_Down);
		}

		return false;
	}
/*
// Input events apparently don't handle repeating when you hold down a key...  Makes this approach painful to use.
//  Requires "menuactive = Menu.WaitKey;" in Ticker()
	override bool OnInputEvent(InputEvent ev)
	{
		if (InputEvent.Type_KeyDown)
		{
			Switch (ev.keyscan)
			{
				case 0:
					break;
				case InputEvent.KEY_ESCAPE:
					menuactive = Menu.On;
					Close();
					MenuEvent(Menu.MKEY_Abort, false);
					return true;
					break;
				default:
					if (
						CheckControl(ev, "+moveleft") ||
						ev.keyscan == InputEvent.KEY_LeftArrow
					) { MenuEvent(MKEY_Left, false); }
					else if (
						CheckControl(ev, "+moveright") ||
						ev.keyscan == InputEvent.KEY_RightArrow
					) { MenuEvent(MKEY_Right, false); }
					else if (
						CheckControl(ev, "+use") ||
						ev.keyscan == InputEvent.KEY_Enter
					) { MenuEvent(MKEY_Enter, false); }
					else if (
						CheckControl(ev, "+forward") ||
						CheckControl(ev, "+back")
					) { MenuEvent(MKEY_Back, false); }
					return true;
					break;
			}
		}

		return false;
	}


	bool CheckControl(InputEvent ev, String control)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		if (ev.keyscan == c1 || ev.keyscan == c2) { return true; }

		return false;
	}
*/
	void CheckControl(UIEvent ev, String control, int type)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		Array<String> keys;
		Bindings.NameKeys(c1, c2).Split(keys, ", ");

		String keychar = String.Format("%c", ev.KeyChar);
		keychar = keychar.MakeUpper();

		for (int i = 0; i < keys.Size(); i++)
		{
			if (keys[i].Length() > 1) { continue; } // Skip named keys (Alt, Shift, Ctrl, etc.)

			if (keys[i].ByteAt(0) == keychar.ByteAt(0))
			{
				MenuEvent(type, false);
			}
		}
	}

	void TryOpen()
	{
		int match = true;

		for (int i = 0; i < 3; i++)
		{
			// Allow a step to either side of the correct number to be accepted
			if (combo[i] >= solution[i] - 1 && combo[i] <= solution[i] + 1) { continue; }
			if (solution[i] == 0 && combo[i] >= steps - 1) { continue; }

			match = false;
		}

		if (match)
		{
			S_StartSound("safe/open", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.5);
			EventHandler.SendNetworkEvent("opensafe", int(s.pos.x), int(s.pos.y), int(s.pos.z));

			Close();
		}
		else
		{
			S_StartSound("safe/locked", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.5);
		}
	}

	void DoReset()
	{
		for (int i = 0; i < 3; i++) { combo[i] = 0; }
		count = 0;
		set = 0;
	}
}

class ViewItem : BoAMenu
{
	TextureID background;
	Vector2 location, size, bgsize, screendimensions;
	double scale, fontscale, linespacing, alpha, msgalpha;

	bool initial;
	int ticcount, closetime, start, maxy, maxlines, pagewidth;

	// Strikethroughs to draw, as pairs of ints representing the line number
	// and width respectively.
	Array<int> strikes;

	BrokenLines hintlines;
	double hintx, hinty, hintlineheight;

	BrokenLines textlines;
	double textx, texty, textlineheight;

	Font msgfont;

	Actor item;
	Sound PickupSound;

	override void Init(Menu parent)
	{
		Super.Init(parent);

		item = players[consoleplayer].ConversationNPC;

		texty = 55;
		maxy = 428;
		fontscale = 0.5;
		linespacing = 1.5;
		pagewidth = 250;

		String text, paper, fnt;

		if (item)
		{
			paper = "PAPER" .. item.args[1];

			switch (item.args[1])
			{
				case 3:
					texty = 108;
					break;
				case 4:
					texty = 168;
					break;
				case 6: 
					texty = 220;
					maxy = 308;
					break;
				case 7: 
					texty = 195;
					maxy = 296;
					break;
				case 8:
					maxy = 375;
				default:
					break;
			}

			int fontstyle = item.args[2];

			// Hacky workaround for fonts that don't have Cyrillic characters
			if (language.Left(2) ~== "ru")
			{
				switch (fontstyle)
				{
					case 1:
						fontstyle = 2;
						break;
					case 4:
						fontstyle = 5;
						break;
				}
			}

			switch (fontstyle)
			{
				case 1:
					fnt = "AMH18";
					fontscale *= 0.875;
					linespacing = 1.25;
					break;
				case 3:
					fnt = "RUN14";
					break;
				case 4:
					fnt = "CHICKN24";
					fontscale *= 0.875;
					linespacing = 1.0;
					break;
				case 5:
					fnt = "handwriting_neat";
					break;
				case 6:
					fnt = "handwriting_institute";
					linespacing = 1.2;
					break;
				case 7:
					fnt = "NewConsoleFont";
					fontscale *= 1.5;
					break;
				case 8:
					fnt = "MavenProSmall";
					fontscale *= 1.2;
					linespacing = 1.2;
					break;
				case 2:
				default:
					fnt = "typewriter";
					linespacing = 1.4;
					break;
			}

			msgfont = Font.GetFont(fnt); // Needed because ConstructSecretHintText uses the msgfont
			if (!msgfont) { msgfont = SmallFont; }

			// draw text from args; is this used on any map?
			if (TextPaper(item))
			{
				text = TextPaper(item).user_displaystring;
				if (paper == "PAPER0") { paper = TextPaper(item).user_displayimage; }
			}
			else if (TextPaperCollectible(item))
			{
				text = TextPaperCollectible(item).user_displaystring;
				if (paper == "PAPER0") { paper = TextPaperCollectible(item).user_displayimage; }
			}
			else if (TextPaperSecretHint(item)) {
				text = TextPaperSecretHint(item).user_displaystring;
			}
			else if (CastleWolfensteinMap(item)) {
				text = "PAPERTEXT00";
				paper = "PAPER9";
			}
			//no custom text provided, use text from localized stringtable
			if (text == "")
			{
				if (TextPaper(item) || TextPaperCollectible(item)) { text = String.Format("PAPERTEXT%02i", item.args[0]); }
				else if (TextPaperSecretHint(item)) { text = ConstructSecretHintText(TextPaperSecretHint(item)); }
			}

			if (Inventory(item)) { PickupSound = Inventory(item).PickupSound; }
			else if (TextPaper(item)) { PickupSound = TextPaper(item).PickupSound; }
			else { PickupSound = "pickup/generic"; }
		}

		// Background graphic
		background = TexMan.CheckForTexture(paper, TexMan.Type_Any);
		bgsize = TexMan.GetScaledSize(background);
		scale = 0.95;
		if (CastleWolfensteinMap(item))
		{
			scale = 0.45;
		}
		location = (320, 240);

		// Hint message
		String hintmessage = StringTable.Localize("PAPERTEXTHOLD", false);
		hintlines = SmallFont.BreakLines(hintmessage, min(pagewidth + 50, 320));

		hintx = 320;
		hintlineheight = SmallFont.GetHeight();

		double offset = hintlineheight * (hintlines.Count() - 0.5);

		hinty = 470 - offset;
		location.y -= offset;
		maxy = int(maxy - (hintlineheight * (hintlines.Count() - 1.0)));

		// Text content
		msgfont = Font.GetFont(fnt);
		if (!msgfont) { msgfont = SmallFont; }

		String textmessage = "";

		if (!(text == "PAPERTEXT00")) // Don't show any text if nothing was set up for display...
		{
			textmessage = StringTable.Localize(text, false);
		}

		textlines = msgfont.BreakLines(textmessage, int(pagewidth / fontscale));

		textx = 320 - pagewidth / 2;
		textlineheight = msgfont.GetHeight() * linespacing * fontscale;
		maxlines = int((maxy - texty) / textlineheight);
		texty -= offset;

		// Menu setup
		DontDim = true;
		menuactive = Menu.On; // Must set to 'On' first instead of straight to WaitKey in order to not end up with stuck controls

		initial = true;
		closetime = 0;
	}

	override void Drawer()
	{
		screen.Dim(0x000000, 0.2 * alpha, 0, 0, screen.GetWidth(), screen.GetHeight());
		int nextStrikeLine = 0, nextStrikeWidth = 0, nextStrikeIndex = 0;

		if (strikes.Size() > 0)
		{
			nextStrikeLine = strikes[0];
			nextStrikeWidth = strikes[1];
		}

		if (alpha > 0)
		{
			if (background)
			{
				screen.DrawTexture(background, true, location.x, location.y, DTA_DestWidth, int(bgsize.x * scale), DTA_DestHeight, int(bgsize.y * scale), DTA_VirtualWidth, 640, DTA_VirtualHeight, 480, DTA_CenterOffset, true, DTA_Alpha, alpha);
			}

			if (textlines)
			{
				int skipcount;
				for (int i = start; i < min(start + maxlines, textlines.Count() - skipcount); i++)
				{
					int curLine = i + skipcount;
					String text = textlines.StringAt(curLine);

					if (i == start && text.length() <= 2)
					{
						skipcount++;
						i--;
					}
					else
					{
						screen.DrawText(msgfont, Font.CR_UNTRANSLATED, textx / fontscale, texty / fontscale + textlineheight * (i - start) / fontscale, text, DTA_VirtualWidth, int(640 / fontscale), DTA_VirtualHeight, int(480 / fontscale), DTA_Alpha, alpha);
						if (curLine == nextStrikeLine)
						{
							screen.DrawThickLine(int(textx / fontscale), int(texty / fontscale) + textlineheight * i, int(textx / fontscale) + nextStrikeWidth, int(texty / fontscale) + textlineheight * i, 2.25, Color(0, 0, 0, 100));
							if (strikes.Size() >= (++nextStrikeIndex) * 2)
							{
								nextStrikeLine = strikes[nextStrikeIndex * 2];
								nextStrikeWidth = strikes[nextStrikeIndex * 2 + 1];
							}
						}
					}
				}


				if (textlines.Count() > maxlines)
				{
					bool l, r;

					if (start > 0)
					{
						if (start + maxlines > textlines.Count())
						{
							l = true;
							r = false;
						}
						else
						{
							l = true;
							r = true;
						}
					}
					else
					{
						l = false;
						r = true;
					}

					if (l) { screen.DrawText(msgfont, Font.CR_UNTRANSLATED, (textx + pagewidth - 32 - 4) / fontscale, maxy / fontscale, "<", DTA_VirtualWidth, int(640 / fontscale), DTA_VirtualHeight, int(480 / fontscale), DTA_Alpha, alpha); }
					if (r) { screen.DrawText(msgfont, Font.CR_UNTRANSLATED, (textx + pagewidth - 32 + 4) / fontscale, maxy / fontscale, ">", DTA_VirtualWidth, int(640 / fontscale), DTA_VirtualHeight, int(480 / fontscale), DTA_Alpha, alpha); }
				}
			}
		}

		if (msgalpha > 0)
		{
			for (int i = 0; i < hintlines.Count(); i++)
			{
				screen.DrawText(SmallFont, Font.CR_GRAY, hintx - hintlines.StringWidth(i) / 2, hinty + hintlineheight * i, hintlines.StringAt(i), DTA_VirtualWidth, 640, DTA_VirtualHeight, 480, DTA_Alpha, msgalpha);
			}
		}
	}

	override void Ticker()
	{
		ticcount++;

		if (closetime > 0)
		{
			closetime--;
			alpha = closetime / 5.0;
		}

		if (initial)
		{
			if (ticcount >= 245)
			{
				msgalpha = 0;
				ticcount = 0;
				initial = false;
			}
			else if (ticcount <= 175)
			{
				if (ticcount == 10) { S_StartSound(PickupSound, CHAN_ITEM, CHANF_UI | CHANF_NOSTOP, 1.0); }

				if (ticcount >= 105)
				{
					msgalpha = 0.5 + sin(((ticcount - 70) * 360 / 70 - 90) / 2);
				}
				else if (ticcount >= 35 && ticcount < 105)
				{
					msgalpha = 1.0;
					alpha = msgalpha;
				}
				else
				{
					menuactive = Menu.WaitKey;
					msgalpha = 0.5 + sin((ticcount * 360 / 70 - 90) / 2);
					alpha = msgalpha;
				}
			}
		}

		if (ticcount > 5 && alpha <= 0)
		{
			closetime = 0;
			Close();

			if (Inventory(item)) { S_StartSound("pickup/item", CHAN_ITEM, CHANF_UI | CHANF_NOSTOP, 1.0); }
		}

		Super.Ticker();
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		switch (mkey)
		{
			case MKEY_Up:
			case MKEY_Left:
				if (start > 0) { start = max(0, start - maxlines); }
				return true;
			case MKEY_Down:
			case MKEY_Right:
				if (start < textlines.Count() - maxlines) { start = start + maxlines; }
				return true;
			case MKEY_Back:
			case MKEY_Enter:
				DoClose();
				return true;
			default:
				return false;
		}
	}

	override bool MouseEvent(int type, int x, int y)
	{
		return false;
	}

	override bool OnInputEvent(InputEvent ev)
	{
		if (ticcount < 5) { return false; }

		if (ev.type == InputEvent.Type_KeyDown)
		{
			switch (ev.keyscan)
			{
				case InputEvent.Key_Escape:
				case InputEvent.Key_Enter:
					MenuEvent(MKEY_Back, false);
					return true;
					break;
				case InputEvent.Key_LeftArrow:
				case InputEvent.Key_UpArrow:
					MenuEvent(MKEY_Left, false);
					return true;
					break;
				case InputEvent.Key_RightArrow:
				case InputEvent.Key_DownArrow:
					MenuEvent(MKEY_Right, false);
					return true;
					break;
				case InputEvent.Key_Mouse1:
					if (start < textlines.Count() - maxlines) { MenuEvent(MKEY_Right, false); }
					else { MenuEvent(MKEY_Back, false); }
					return true;
					break;
			}

			CheckInput(ev, "+moveleft", MKEY_Left);
			CheckInput(ev, "+moveright", MKEY_Right);
			CheckInput(ev, "+use", MKEY_Enter);
			CheckInput(ev, "+forward", MKEY_Up);
			CheckInput(ev, "+back", MKEY_Down);
		}

		return false;
	}

	bool CheckInput(InputEvent ev, String control, int type)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		if (ev.keyscan == c1 || ev.keyscan == c2)
		{
			MenuEvent(type, false);
			return true;
		}

		return false;
	}

	void DoClose()
	{
		if (!closetime)
		{
			initial = false;
			closetime = 5;
		}
	}
	
	string ConstructSecretHintText(TextPaperSecretHint item) {
		if (!item.args[0]) return "";
		string base_name = "SECRET"..item.args[0], data, result;
		int i = 1, curToken, stringLine = 0;
		// Keep processing consecutive SECRET<i> strings until an entry doesn't exist
		while ((data = StringTable.Localize(base_name..i, false)) != base_name..i) {
			//itemids: ??? = 1, Weapon = 2, Grenade(s) = 3(4), Gold (small, moderate, large, TREMENDOUS) = (5, 6, 7, 8), Ammo (small, moderate, large, TREMENDOUS) = (9, 10, 11, 12), Health (small, moderate, large, TREMENDOUS) = (13, 14, 15, 16), Armor = 17, Various Supplies = 18
			//now decipher the data string which was passed
			//the format is: t or s|comment|id|itemid|[itemid|[...]], example: "t|check the roof|1993|5|17" means thing with tag 1993 is a secret which gives access to a small amount of gold and an armor suit and tells the player to search for these on a roof.
			Array<String> tokens;
			data.Split(tokens, "|");
			if (tokens.size() < 4) { Console.Printf("ConstructSecretHintText(): Incorrect hint format."); continue; }
			// Start each secret with a number in point form
			result = result .. "\cM" .. i .. ". "; // \cM = black
			bool secret_found;
			// What is this secret? A thing? A sector?
			if (tokens[0] == "t") // Thing secret, a TID is given
			{
				// Find the secret item
				ActorIterator it = Level.CreateActorIterator(tokens[2].toInt());
				let item = it.Next();
				// Check whether or not it has been found
				if (item == NULL || !item.bCOUNTSECRET) { secret_found = true; }
				else { secret_found = false; }
			}
			else if (tokens[0] == "s") // Sector secret, a sector number (not a tag) is given
			{
				if (!(Level.sectors[tokens[2].toInt()].flags & Sector.SECF_SECRET)) { secret_found = true; }
				else { secret_found = false; }
			}
            // now construct the line
            // let's pretend that BJ adds the red highlight mentally...
			if (secret_found) { result.AppendFormat("\cG"); }
			else { result.AppendFormat("\cM"); }
			// Add the items in the secret
			for (curToken = 3; curToken < tokens.size(); ++curToken)
			{
				result = result .. StringTable.Localize("SECRETITEM"..tokens[curToken], false);
				if (curToken < tokens.size() - 1)
				{
					result = result .. ";\n";
				}
			}
            if (tokens[1] != "") result.AppendFormat("  \cU"..tokens[1].."\cM\n"); // \cU = dark gray
            else result.AppendFormat("\n"); //crutch...
			// Add line numbers and widths to strikethroughs
			/* commented the strike out, sadly does not work for now --N00b
            BrokenLines lines = msgfont.BreakLines(result, int(pagewidth / fontscale));
			for (int line = 0; line < lines.Count(); line++)
			{
				if (secret_found)
				{
					strikes.Push(stringLine); // Line number
					strikes.Push(lines.StringWidth(line)); // Width
				}
				++stringLine;
			}
            */
			++i;
		}
		return result;
	}
}