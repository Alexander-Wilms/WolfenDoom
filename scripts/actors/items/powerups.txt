class CustomInvBase : CustomInventory
{
	String FailMessage;

	Property FailMessage:FailMessage;

	Default
	{
		//$Category Powerups (BoA)
		//$Color 6
		Scale 0.50;
		CustomInvBase.FailMessage "";
	}

	override bool Use(bool pickup)
	{
		if (level.levelnum == 99)
		{
			if (FailMessage) { Console.MidPrint (null, FailMessage, true); }
			return false;
		}

		return Super.Use(pickup);
	}
}

class PowerupToggler : PowerupGiver
{
	Powerup powerinv;

	override void DoEffect()
	{
		if (globalfreeze || level.Frozen) { return; }
		if (powerinv)
		{
			EffectTics = powerinv.EffectTics;
		}
		if (EffectTics == 1)
		{
			if (amount > 1)
			{
				amount -= 1;
				EffectTics = Default.EffectTics + 1;
			}
			else
			{
				Destroy();
			}
			if (powerinv)
			{
				powerinv.Destroy();
			}
		}
	}

	override void PostBeginPlay()
	{
		// In case powerup duration was not set in the defaults
		if (EffectTics == 0)
		{
			EffectTics = Powerup(GetDefaultByType(PowerupType)).EffectTics;
		}
		// Add 1 tic to the powerup time so that this "toggler" has control
		// over the powerup, and the powerup doesn't get removed without the
		// toggler knowing
		EffectTics += 1;
	}

	override bool Use(bool pickup)
	{
		if (powerinv)
		{
			powerinv.Destroy();
		}
		else
		{
			Super.Use(pickup);
			// Required to work around a type issue
			class<Inventory> PowerType = PowerupType.GetClassName();
			if (PowerType)
			{
				powerinv = Powerup(Owner.FindInventory(PowerType));
			}
		}
		return false; // Don't remove the toggler from owner's inventory.
	}

	override bool TryPickup(in out Actor toucher)
	{
		// Picking up another of the same item
		PowerupGiver toggler = PowerupGiver(toucher.FindInventory(GetClass()));
		if (toggler)
		{
			if (toggler.MaxAmount > 1 && toggler.Amount < toggler.MaxAmount)
			{
				toggler.Amount += 1;
				GoAwayAndDie();
				return true;
			}
			// Type issue workaround
			Class<Inventory> PowerType = PowerupType.GetClassName();
			if (PowerType)
			{
				Powerup curPower = Powerup(toucher.FindInventory(PowerType, true));
				// Powerup is active, modify powerup EffectTics. The toggler
				// will query the EffectTics of the powerup every tic.
				if (curPower)
				{
					if (bAdditiveTime)
					{
						curPower.EffectTics += Default.EffectTics;
						GoAwayAndDie();
						return true;
					}
					else if (curPower.EffectTics < (Default.EffectTics + 1))
					{
						curPower.EffectTics = Default.EffectTics + 1;
						GoAwayAndDie();
						return true;
					}
				}
				else
				{
					// Powerup is not active, modify toggler EffectTics
					if (bAdditiveTime)
					{
						toggler.EffectTics += Default.EffectTics;
						GoAwayAndDie();
						return true;
					}
					else if (toggler.EffectTics < (Default.EffectTics + 1))
					{
						toggler.EffectTics = Default.EffectTics + 1;
						GoAwayAndDie();
						return true;
					}
				}
			}
		}
		return Super.TryPickup(toucher);
	}
}

class ZyklonMask : PowerupToggler
{
	Default
	{
		//$Category Powerups (BoA)
		//$Title Zyklon Mask (any poison protection)
		//$Color 6
		Scale 0.35;
		Tag "$TAGZMASK";
		Inventory.Icon "ZASKB0";
		Inventory.PickupMessage "$ZMASK";
		Inventory.MaxAmount 1;
		Powerup.Duration -60;
		Powerup.Type "PowerZyklonMask";
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
	Spawn:
		ZASK A -1;
		Stop;
	}

	override void DoEffect()
	{
		if (globalfreeze || level.Frozen) { return; }
		// Zyklon mask cannot be used underwater
		if (powerinv && owner.waterlevel >= 3)
		{
			A_StartSound("flamer/steam", CHAN_AUTO, 0, Random(15, 45));
			powerinv.Destroy();
		}
		Super.DoEffect();
	}
}

const CHAN_MASK = 194;

// PowerProtection that plays a looping sound while active
class PowerMaskProtection : PowerProtection
{
	sound maskSound;
	int maskChannel;

	Property Sound: maskSound;
	Property Channel: maskChannel;

	Default
	{
		PowerMaskProtection.Sound "player/gasmask";
		PowerMaskProtection.Channel CHAN_MASK;
	}

	override void InitEffect()
	{
		if (Owner)
		{
			Owner.A_StartSound(maskSound, maskChannel, CHANF_LOOPING);
		}
		Super.InitEffect();
	}

	override void EndEffect()
	{
		if (Owner)
		{
			Owner.A_StopSound(maskChannel);
		}
		Super.EndEffect();
	}
}

class PowerZyklonMask : PowerMaskProtection
{
	Default
	{
		DamageFactor "UndeadPoisonAmbience", 0;
	}

	// PowerZyklonMask shouldn't expire
	override void Tick()
	{
		if (Owner == null || EffectTics == 0)
		{
			Destroy();
		}
	}
}

class PowerSpaceSuit : PowerMaskProtection
{
	Default
	{
		DamageFactor "IceWater", 0;
	}
}

class LanternPickup : CustomInventory
{
	bool active;

	Default
	{
		//$Category Powerups (BoA)
		//$Title Useable Lantern (requires Oil)
		//$Color 6
		Scale 0.5;
		Tag "$TAGLANTR";
		Inventory.Icon "LANTB0";
		Inventory.PickupMessage "$LANTERN";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/gadget_pickup";
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
		Spawn:
			LANT A -1;
			Stop;
		Pickup:
			"####" A 0 A_GiveInventory("LanternOil", 1000);
			Stop;
		Use:
			"####" A 0 {
				invoker.active = !invoker.active;

				if (invoker.active && !FindInventory("LanternOil")) { invoker.active = false; }
			}
			Fail;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		if (owner && active)
		{
			if (owner.waterlevel >= 3)
			{
				A_StartSound("flamer/steam", CHAN_AUTO, 0, Random(15, 45));
				active = false;
			}
			else if (owner.FindInventory("LanternOil")) { owner.TakeInventory("LanternOil", 1); }
			else { active = false; }
		}
	}
}

class MineSweeper : CustomInventory
{
	bool active;

	Default
	{
		//$Category Powerups (BoA)
		//$Title Human Mine Scanning (pickups)
		//$Color 6
		Scale 0.5;
		Tag "$TAGSWEEP";
		Inventory.Icon "MSPUB0";
		Inventory.PickupMessage "$SWEEPER";
		Inventory.MaxAmount 1;
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
		Spawn:
			MSPU A -1;
			Stop;
		Pickup:
			"####" A 0 {
				if (CountInv("MineSweeper") == 0) {
					A_GiveInventory ("Power", 2400);
					return true;
				} else if (CountInv("MineSweeper") > 0 && CountInv("Power") < 2400) {
					A_GiveInventory ("Power", 2400 - CountInv("Power"));
					A_TakeInventory ("MineSweeper", 1); // The player will immediately get another minesweeper.
					return true;
				} else {
					return false;
				}
			}
			Stop;
		Use:
			"####" A 0 {
				invoker.active = !invoker.active;

				if (invoker.active && !FindInventory("Power")) { invoker.active = false; }
			}
			Fail;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen || !owner || !owner.player) { return; }

		if (owner && active)
		{
			if (owner.FindInventory("Power")) { owner.TakeInventory("Power", 1); }
			else { active = false; }
		}
	}
}

class BoACompass : CustomInventory
{
	bool active;

	Default
	{
		//$Category Pickups (BoA)
		//$Title Compass
		//$Color 13
		Scale 0.2;
		Tag "$TAGCOMPS";
		Inventory.Icon "CMPSB0";
		Inventory.PickupMessage "$COMPASS";
		Inventory.PickupSound "misc/armor_head";
		Inventory.MaxAmount 1;
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE // So that it doesn't get removed on C2M2 - Talon1024
	}

	States
	{
		Spawn:
			CMPS A -1;
			Stop;
		Use:
			TNT1 A 0 {
				invoker.active = !invoker.active;
			}
			Fail;
	}

	override Inventory CreateTossable(int amt)
	{
		active = false;
		return Super.CreateTossable(amt);
	}

	static void Add(Actor thing, String iconName = "", bool usesprite = false, int actorTID = 0)
	{
		if (!thing || actorTID)
		{
			if (actorTID)
			{
				let it = ActorIterator.Create(actorTID, "Actor");
				Actor mo;

				while (mo = Actor(it.Next()))
				{
					Add(mo, iconName, usesprite); // Add each thing that has a matching TID
				}
			}

			return; // If no thing was passed, silently fail here
		} 

		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; } // If no CompassHandler was found (somehow), silently fail

		if (iconName == "") { iconName = CompassHandler.GetDefaultIcon(thing, usesprite); }

		compassEvent.Add(thing, iconName);
	}

	static void Remove(Actor thing)
	{
		if (!thing) { return; } // If no thing was passed, silently fail

		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; }

		int i = compassEvent.FindCompassItem(thing);

		if (i < compassEvent.CompassItems.Size())
		{
			compassEvent.CompassItems[i].Destroy();
			compassEvent.CompassItems.Delete(i, 1);
			compassEvent.CompassItems.ShrinkToFit();
		}
	}

	static void Flash()
	{
		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; }

		compassEvent.drawflash = level.time;
	}

	static void ForceActivate(Actor owner, bool activate)
	{
		if (owner && owner.player)
		{
			Inventory cmpsitem = owner.FindInventory("BoACompass");
			if (cmpsitem)
			{
				BoACompass compass = BoACompass(cmpsitem);
				compass.active = activate;
			}
		}
	}
}

// Disguise token to change player sprites and properties
//  Formerly handled in CheckSpriteToken function in BoAPlayer class
//  Properties are named similarly to their corresponding PlayerPawn property
//  If you don't specify a crouch sprite, the standing sprite is used and default squishing applies
//  DropItem list is used as the list of weapons that are allowed to be carried without breaking the disguise
//
// See RyanToken below for simple example.
class DisguiseToken : CustomInventory
{
	int viewheight;
	double playerscale;
	double viewbob;
	double forwardmove1, forwardmove2;
	double sidemove1, sidemove2;
	String HUDsprite;
	SpriteID basesprite, crouchsprite;
	bool notarget;
	int notargettimeout;
	Name playersoundclass;

	Property ViewHeight:viewheight;
	Property PlayerScale:playerscale;
	Property ViewBob:viewbob;
	Property ForwardMove:forwardmove1, forwardmove2;
	Property SideMove:sidemove1, sidemove2;
	Property HUDSprite:HUDsprite;
	Property NoTarget:notarget;
	Property PlayerSoundClass:playersoundclass;
	Default
	{
		+INVENTORY.KEEPDEPLETED
		DisguiseToken.PlayerScale 0.65; // Overrides scale of original player class
		DisguiseToken.ViewHeight -1; // -1 means 'use player class default' for everything below...
		DisguiseToken.ViewBob -1;
		DisguiseToken.ForwardMove -1, -1;
		DisguiseToken.SideMove -1, -1;
		DisguiseToken.HUDSprite "STF"; // Default to using the default mugshot
		DisguiseToken.NoTarget True; // If True, disguise hides player from Nazis.  If False, player just uses alternate skin but is fired at normally.
		DropItem "NullWeapon"; // Misappropriate DropItem to list weapons that can be equipped without breaking disguise
		DropItem "FakeID", 1; // Drop probability is used as a flag field; set to 1 to allow this weapon to be fired in disguise and to not alert enemies
	}

	States
	{
		Use:
			TNT1 A -1;
			Stop;
		// Define WalkSprite (and CrouchSprite, if used) in token actor's states
		WalkSprite:
			PLAY A 0;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		State WalkState = FindState("WalkSprite");
		State CrouchState = FindState("CrouchSprite");

		basesprite = WalkState.sprite;

		if (CrouchState) { crouchsprite = CrouchState.sprite; }
	}

	override void Tick()
	{
		Super.Tick();

		let p = PlayerPawn(owner);

		if (!p || !p.player) { return; }

		if (Amount > 0) // Apply token-specific settings and sprites to the player
		{
			if (playerscale > 0) { p.scale = (1.0, 1.0) * playerscale; }

			if (crouchsprite && p.player.crouchfactor < 0.75)
			{
				p.sprite = crouchsprite;
				p.scale.y *= 1.0 / p.player.crouchfactor; // Negate crouch sprite scaling
			}
			else
			{
				p.sprite = basesprite;
			}

			if (viewheight > -1)
			{
				p.viewheight = viewheight;
				p.attackzoffset = p.Default.attackzoffset * viewheight / p.Default.viewheight;
			}

			if (p.scale.x != playerscale) { p.A_SetSize(p.Default.radius * p.scale.x / p.Default.scale.x, p.Default.height * p.scale.y / p.Default.scale.y); }

			if (viewbob > -1) { p.viewbob = viewbob; }
			if (forwardmove1 > -1 && forwardmove2 > -1) { p.forwardmove1 = forwardmove1; p.forwardmove2 = forwardmove2; }
			if (sidemove1 > -1 && sidemove2 > -1) { p.sidemove1 = sidemove1; p.sidemove2 = sidemove2; }

			if (notarget) { SetNoTarget(); }
			
			if (playersoundclass) { p.SoundClass = playersoundclass; }
		}
		else // Restore player defaults
		{
			p.sprite = p.SpawnState.sprite;
			p.viewheight = p.Default.viewheight;
			p.attackzoffset = p.Default.attackzoffset;
			if (p.scale != p.Default.scale)
			{
				p.scale = p.Default.scale;
				p.A_SetSize(p.Default.radius, p.Default.height);
			}
			p.viewbob = p.Default.viewbob;
			p.forwardmove1 = p.Default.forwardmove1;
			p.forwardmove2 = p.Default.forwardmove2;
			p.sidemove1 = p.Default.sidemove1;
			p.sidemove2 = p.Default.sidemove2;
			p.soundclass = p.Default.soundclass;
			
			Destroy();
		}
	}

	void SetNoTarget()
	{
		bool hide = true;
		let weap = owner.player.ReadyWeapon;

		if (weap && !owner.FindInventory("DisguiseFailToken", true))
		{
			DropItem allowedweapons = GetDropItems();

			if (allowedweapons)
			{
				for (DropItem weaponitem = allowedweapons; weaponitem != null; weaponitem = weaponitem.Next)
				{
					Class<Weapon> testweapon = weaponitem.Name;

					if (testweapon && testweapon == weap.GetClass())
					{
						let psp = owner.player.GetPSprite(PSP_WEAPON);

						if ( // If in ready state, up state, or down state, turn notarget on unless enemies are already alerted
							!owner.player.FindPSprite(-10) && // Kicks make you lose your disguise
							(
								weaponitem.Probability != 255 ||
								psp.CurState == weap.GetReadyState() ||
								psp.CurState == weap.GetUpState() ||
								psp.CurState == weap.GetDownState()
							)
						) 
						{
							Inventory vis = owner.FindInventory("BoAVisibility");	

							if (!vis || !BoAVisibility(vis).alertedcount) // If no enemies are already alerted, turn on notarget
							{
								notargettimeout = level.time + 2;
							}
						}
						else
						{
							notargettimeout = level.time;
						}

						break;
					}
				}
			}
		}

		if (notargettimeout)
		{
			if (notargettimeout <= level.time) // Turn off notarget and reset speed
			{
				owner.player.cheats &= ~CF_NOTARGET;
				owner.speed = owner.Default.speed;

				notargettimeout = 0;
			}
			else // Turn on notarget and slow down your movement
			{
				owner.player.cheats |= CF_NOTARGET;
				owner.speed = owner.Default.speed * 0.85;
			}
		}
	}
}

class RyanToken : DisguiseToken
{
	Default
	{
		DisguiseToken.ViewBob 0.22; // Less bob then BJ
		DisguiseToken.ForwardMove 0.9, 0.45; // Just a little slower than BJ
		DisguiseToken.SideMove 0.9, 0.45;
		DisguiseToken.HUDSprite "RTF"; // Ryan Mugshot
		DisguiseToken.PlayerSoundClass "ryan"; // soundclass
		DisguiseToken.NoTarget False; // Don't hide player from enemies
	}

	States
	{
		WalkSprite:
			PLRR A 0;
		CrouchSprite:
			PLYR A 0;
	}
}

class PowerRepairing : Powerup
{
	Default
	{
		Powerup.Duration -15;
		Powerup.Strength 3; // Per tic HP increase
	}

	override void DoEffect()
	{
		Super.DoEffect();
		if (!Owner)
		{
			return;
		}
		else if (Owner is "ShermanPlayer")
		{
			// I would like to transfer the powerup to the tank body if the
			// player exits the tank, but I don't know if that is even possible.
			Owner.GiveBody(int(Strength), GetDefaultByType("ShermanPlayer").Health);
		}
		else
		{
			Destroy();
		}
	}
}

class RepairKit : CompassItem
{
	Default
	{
		//$Title Repair Kit (electric)
		-INVENTORY.ALWAYSPICKUP
		Tag "$TAGREKIT";
		Inventory.Icon "EKPKA0";
		Inventory.PickupMessage "$ELECPAK";
		Inventory.PickupSound "misc/gadget_pickup";
		Inventory.MaxAmount 3;
	}

	States
	{
	Spawn:
		EKPK B -1;
		Stop;
	}

	override bool Use(bool pickup)
	{
		if (Owner.FindInventory("PowerRepairing"))
		{
			return false;
		}
		if (Owner is "ShermanPlayer")
		{
			Inventory repairing = Owner.GiveInventoryType("PowerRepairing");
			return true;
		}
		return false;
	}
}

class Bandages : PowerupGiver
{
	Default
	{
		//$Category Health (BoA)
		//$Title Bandages (+10)
		//$Color 6
		Scale 0.5;
		Tag "$TAGBAIDS";
		Inventory.Icon "BAIDB0";
		Inventory.MaxAmount 5;
		Inventory.PickupMessage "$BAID";
		Inventory.UseSound "pickup/bandage";
		Inventory.PickupSound "misc/health_pkup";
		Powerup.Type "RegenPowerup";
	}

	States
	{
		Spawn:
			BAID A -1;
			Stop;
	}

	// Don't let the player use bandages when they are at full health!
	override bool Use(bool pickup)
	{
		if (owner && owner.health >= owner.GetMaxHealth(true)) { return false; }

		return Super.Use(pickup);
	}
}

class RegenPowerup : PowerUp
{
	Sound regensound;
	int regeninterval;

	Property RegenSound : regensound;
	Property RegenInterval : regeninterval;

	Default
	{
		Powerup.Duration -10;
		Powerup.Strength 1;

		RegenPowerup.RegenSound "*regenerate";
		RegenPowerup.RegenInterval TICRATE;
	}

	// Derived from base PowerRegeneration class, but using actual ticrate-based seconds instead of running every 32 tics
	override void DoEffect()
	{
		Super.DoEffect();

		if (owner && owner.health > 0 && (Level.maptime % regeninterval) == 0)
		{
			if (Owner.GiveBody(int(Strength)))
			{
				Owner.A_StartSound(regensound, CHAN_ITEM);
			}
		}
	}
}

class ZyklonResistance: PowerupGiver
{
	Default
	{
		+INVENTORY.INVBAR
		Radius 8;
		Height 16;
		Scale 0.3;
		Inventory.Icon "BEAKD0";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/k_pkup";
		Inventory.PickupMessage "$ZRESIST";
		Powerup.Duration 0x7FFFFFFF;
		Powerup.Type "PowerZyklonResistance";
	}

	States
	{
		Spawn:
			BEAK D -1 BRIGHT;
			Stop;
	}
}

class PowerZyklonResistance : PowerProtection
{
	Default
	{
		DamageFactor "UndeadPoison", 0.25;
		DamageFactor "UndeadPoisonAmbience", 0.25;
	}
}

class SavingHealth : CustomInvBase
{
	String savemessage;

	Property SaveMessage : savemessage;
}

class NaziBerserk : SavingHealth
{
	Default
	{
		//$Title Totale Macht (Berserk)
		//$Sprite PSTRA0
		+INVENTORY.INVBAR
		Inventory.Icon "I_BSRK";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/p_pkup";
		Inventory.PickupMessage "$SSBERSK";
		Tag "$TAGBERSP";
		SavingHealth.SaveMessage "$TMSAVE";
	}

	States
	{
		Spawn:
			PSTR A -1;
			Loop;
		Pickup:
			Stop;
		Use:
			TNT1 A 0
			{
				A_GiveInventory("BerserkRegen", 1);
				A_GiveInventory("BerserkReflect", 1);
				A_GiveInventory("BerserkToken", 1);
			}
			Stop;
	}
}

class BerserkToken : PowerUp // Token is checked for in ACS-based sprint handling - no stamina use for the duration of this powerup!
{
	Default
	{
		Powerup.Duration -30;
	}
}


class BerserkRegen : RegenPowerUp
{
	double blendstep;
	bool initial;

	Default
	{
		Powerup.Duration -60;
		Powerup.Color "00 7D 5C", 0.5; // Zyklon green
		RegenPowerUp.RegenSound "";
		RegenPowerUp.RegenInterval 1; // Start healing quickly...
	}

	override void InitEffect()
	{
		Super.InitEffect();

		owner.A_StartSound("activate/macht", CHAN_AUTO, CHANF_LOCAL, 15.0, 0.5);
		owner.A_StartSound("EXPDSND5", CHAN_AUTO, CHANF_LOCAL, 15.0, 0.25);
		initial = true;
	}

	override void DoEffect()
	{
		Super.DoEffect();

		if (owner && owner.health > 0 && (Level.maptime % TICRATE) == 0)
		{
			regeninterval++; // ...and decrease healing rate over time.
		}
	}

	override color GetBlend()
	{
		double amt;

		if (effecttics < 175) // Pulse when there are 5 seconds left
		{
			if (effecttics == 174 || effecttics % TICRATE == 0) { blendstep = 0; }

			amt = sin(blendstep) / 4;
			blendstep += 90.0 / TICRATE;
		}
		else if (initial || (Level.maptime % TICRATE) != 0)
		{
			if (initial) // Always flash over two seconds on initial activation
			{
				amt = sin(blendstep);
				blendstep += 45.0 / TICRATE;

				if (blendstep >= 180.0)
				{
					blendstep = 0;
					initial = false;
				}
			}
			else // Flash every second after that, with more transparency the healthier you are and the weaker the effect gets
			{
				amt = (1.0 - double(owner.health) / owner.GetMaxHealth(true)) * sin(blendstep) * double(effecttics) / Default.effecttics;
				blendstep += 90.0 / TICRATE;
			}
		}
		else
		{
			blendstep = 0;
		}

		if (amt) { return Color(int(BlendColor.a * amt), BlendColor.r, BlendColor.g, BlendColor.b); }

		return 0;
	}
}

class BerserkReflect : PowerUp
{
	Default
	{
		Powerup.Duration -10;
	}

	override void DoEffect()
	{
		Super.DoEffect();

		if (owner)
		{
			owner.DamageFactor = 0.0; // Basically set the player invulnerable without setting the flag, so the mugshot won't change
			owner.bReflective = true;
		}
	}

	override void EndEffect ()
	{
		Super.EndEffect();

		if (owner)
		{
			owner.DamageFactor = owner.Default.DamageFactor;
			owner.bReflective = false;
		}
	}
}

class TotaleGier : CustomInvBase // Checked within Nazi class to drop coins on death for duration of this item
{
	Default
	{
		//$Title Totale Gier (Make enemies drop gold when killed)
		//$Sprite TTGRA0
		+INVENTORY.INVBAR
		Inventory.Icon "I_TTGR";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/p_pkup";
		Inventory.PickupMessage "$SSGIER";
		Tag "$TAGGIER";
	}

	States
	{
		Spawn:
			TTGR A -1;
			Loop;
		Pickup:
			Stop;
		Use:
			TNT1 A -1
			{
				A_GiveInventory("GierToken", 1);
			}
			Stop;
	}
}


class GierToken : PowerUp // Token is checked for in Nazi class to cause enemies that are killed by the owner to drop coins on death
{
	double blendstep;

	Default
	{
		Powerup.Color "88 66 00", 0.65; // Gold flash
		Powerup.Duration -60;
	}

	override void InitEffect()
	{
		Super.InitEffect();

		owner.A_StartSound("activate/gier", CHAN_AUTO, CHANF_LOCAL, 1.0, 2.0);

		if (owner.player.mo == players[consoleplayer].camera)
		{
			StatusBar.SetMugshotState("Grin");
		}
	}

	override color GetBlend()
	{
		double amt;
		if (effecttics < 175) // Pulse when there are 5 seconds left
		{
			if (effecttics == 174 || effecttics % TICRATE == 0) { blendstep = 0; }

			amt = sin(blendstep) / 4;
			blendstep += 90.0 / TICRATE;
		}
		else if (blendstep < 180.0)  // Fast flash of gold on activation
		{
			amt = sin(blendstep);
			blendstep += 135.0 / TICRATE;
		}

		if (amt) { return Color(int(BlendColor.a * amt), BlendColor.r, BlendColor.g, BlendColor.b); }
		
		return 0;
	}
}