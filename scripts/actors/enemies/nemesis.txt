/*
 * Copyright (c) 2020 Talon1024
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class SpotFinderTracer : LineTracer
{
	// Set by the callback
	bool hitWall;

	override ETraceStatus TraceCallback()
	{
		if (Results.HitType == TRACE_HitFloor || Results.HitType == TRACE_HitCeiling)
		{
			hitWall = true;
			return TRACE_Stop;
		}
		else if (Results.HitType == TRACE_HitWall)
		{
			// Walls need further examination
			if (Results.Tier != TIER_Middle)
			{
				hitWall = true;
				return TRACE_Stop;
			}
		}
		return TRACE_Skip;
	}
}

class YourNemesis : Demon
{ // AKA ImmortalPinky AKA ImmortalDemon

	Default
	{
		Health 300;
		+JUMPDOWN
	}

	States
	{
	Death:
		SARG I 8;
		SARG J 8 A_Scream;
		SARG K 4;
		SARG L 4 A_NoBlocking;
		SARG M 4;
		SARG N 105; // Use 10500 = 5 minutes for the final enemy, 3 seconds is easier to test with.
		SARG N -1 A_RaiseSelf(RF_NOCHECKPOSITION); // Doesn't work if duration is 0 for some reason
		Stop;
	Raise:
		SARG N 5 { bSolid = false; bShootable = false; }
		SARG MLKJI 5;
		SARG A 0; // Set frame you see while disappearing
		"####" "#" 1 A_FadeOutJump(0.125, "Teleport");
		Wait;
	Teleport:
		TNT1 A 105 A_TeleportCloseTo(180, 384, "Reappear");
		Loop;
	Reappear:
		SARG A 1 {
			bSolid = true; bShootable = true;
			A_FadeInJump(0.125, "See");
		}
		Wait;
	}

	void A_FadeOutJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeOut(fadeAmount, flags);
		if (Alpha <= 0.0)
		{
			SetStateLabel(label);
		}
	}

	void A_FadeInJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeIn(fadeAmount, flags);
		if (Alpha >= 1.0)
		{
			SetStateLabel(label);
		}
	}

	// Checks whether the given angle is suitable for teleporting to. Returns the distance at the given angle which is suitable, or -1 if it is not suitable.
	double isAngleSuitable(double angle, double maxdistance, double checkIncrement = 8)
	{
		double suitableDistance = -1;
		SpotFinderTracer finder = new("SpotFinderTracer");
		double zDiff = target.Pos.Z - Pos.Z;
		Vector3 traceDirection = (cos(angle), sin(angle), 0);
		Vector3 traceOrigin = target.Pos;
		traceOrigin.Z += MaxStepHeight;
		finder.Trace(traceOrigin, target.CurSector, traceDirection, maxdistance, 0);
		// There is a wall blocking this angle!
		if (finder.hitWall)
		{
			maxdistance = finder.Results.Distance;
		}
		Vector3 oldPosition = Pos;
		Vector2 checkDirection = AngleToVector(angle);
		double checkDistance = maxdistance;
		// Check for a suitable spot to reappear at. Start at the furthest point, and close in to the target's position.
		for (
			Vector2 positionToCheck = target.Pos.XY + checkDirection * checkDistance;
			-((positionToCheck - target.Pos.XY) dot checkDirection) > 0;
			checkDistance -= checkIncrement,
			positionToCheck = target.Pos.XY + checkDirection * checkDistance
		){
			SetOrigin((positionToCheck, target.Pos.Z), false);
			if (TestMobjLocation())
			{
				suitableDistance = checkDistance;
				break;
			}
		}
		SetOrigin(oldPosition, false);
		return suitableDistance;
	}

	State A_TeleportCloseTo(double preferredAngle = 180, double maxdistance = 384, StateLabel toJumpTo = null)
	{
		if (!target) {return null;}
		State appearState = FindState(toJumpTo, true);
		preferredAngle = target.Angle + preferredAngle;
		double suitableDistance = -1;
		double traceAngle = 0;
		for (double angleOffset = -90; angleOffset < 90; angleOffset += 0.5)
		{
			traceAngle = preferredAngle + floor(angleOffset);
			// Check in the other direction
			if (ceil(angleOffset) != angleOffset)
			{
				traceAngle = 360 - traceAngle;
			}
			suitableDistance = isAngleSuitable(traceAngle, maxdistance);
			if (isAngleSuitable(traceAngle, maxdistance))
			{
				break;
			}
		}
		if (suitableDistance == -1)
		{
			return null;
		}
		SetOrigin(target.Vec3Angle(suitableDistance, traceAngle), false);
		return appearState;
	}
}