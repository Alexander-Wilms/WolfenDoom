/*
 * Copyright (c) 2020 Talon1024
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class SpotFinderTracer : LineTracer
{
	// Set by the callback
	bool hitWall;

	override ETraceStatus TraceCallback()
	{
		if (Results.HitType == TRACE_HitFloor || Results.HitType == TRACE_HitCeiling)
		{
			hitWall = true;
			return TRACE_Stop;
		}
		else if (Results.HitType == TRACE_HitWall)
		{
			// Walls need further examination
			if (Results.Tier != TIER_Middle)
			{
				hitWall = true;
				return TRACE_Stop;
			}
			else
			{
				if (!(Results.HitLine.flags & Line.ML_TWOSIDED))
				{
					// Not a two-sided wall
					hitWall = true;
					return TRACE_Stop;
				}
				else
				{
					// Two-sided wall
					if (Results.HitLine.flags & Line.ML_BLOCKING)
					{
						hitWall = true;
						return TRACE_Stop;
					}
				}
			}
		}
		return TRACE_Skip;
	}
}

// Base class for missiles that travel on the floor
class GroundedMissile : GrenadeBase
{
	Default
	{
		Health 1;
		Projectile;
		-NOGRAVITY
		+NOEXPLODEFLOOR
		+STEPMISSILE
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (!MaxStepHeight)
		{
			MaxStepHeight = Speed;
		}
	}

	override void Tick()
	{
		Super.Tick();
		if (health <= 0) return;
		double floorz = CurSector.NextLowestFloorAt(Pos.X, Pos.Y, Pos.Z, steph: MaxStepHeight);
		double minz = floorz + MaxStepHeight;
		if (Pos.Z <= minz)
		{
			Vel.Z = 0;
			AddZ(minz - Pos.Z);
			Vel.XY = AngleToVector(Angle, Speed);
		}
	}
}

/*
// GroundedMissile class test
class GroundedEnergyBolt : GroundedMissile
{
	Default
	{
		DamageFunction (40);
		Speed 15;
		Gravity .125;
		GrenadeBase.FearDistance 64;
		GroundedMissile.AirHeight 8;
		+BRIGHT
	}

	States
	{
	Spawn:
		ROBP AB 4;
		Loop;
	Death:
		ROBP CDEG 6;
		Stop;
	}
}
*/

/*
class NemesisZyklonCloud : Actor
{
	Actor origin;

	Default
	{
		Damage 0;
		Scale .375;
		Speed 7;
		Projectile;
		+RIPPER
		+NOCLIP
	}

	States
	{
	Spawn:
		AWCF EEEE 4 {
			A_ZyklonAOE(32, 64);
			A_CloudWander();
		}
		AWCF E 0 A_FadeOut(.125, FTF_REMOVE);
		Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		origin = Spawn("MapSpot", Pos, NO_REPLACE);
		SpriteOffset.Y = 70;
	}

	void A_CloudWander(double maxdistance = 128)
	{
		// Move towards origin if too far away
		double angle = frandom(0.0, 360.0);
		if (Distance2DSquared(origin) >= (maxdistance * maxdistance))
		{
			// Otherwise, just move in a completely random direction
			angle = AngleTo(origin);
		}
		Vel.XY = AngleToVector(angle, Speed);
	}

	void A_ZyklonAOE(int damage, double radius, double ambientPercent = 0.0)
	{
		double ambient = double(damage) * ambientPercent;
		int ambientDamage = ambient;
		int realDamage = damage - ambient;
		A_Explode(ambientDamage, radius, 0, damagetype: "UndeadPoisonAmbience");
		A_Explode(realDamage, radius, 0, damagetype: "UndeadPoison");
	}

	override void OnDestroy()
	{
		origin.Destroy();
		Super.OnDestroy();
	}
}
*/

class NemesisZyklonClouder : GroundedMissile
{
	Default
	{
		DamageFunction (40);
		Radius 24;
		Height 16;
		Speed 10;
		Gravity .25;
		MaxStepHeight 16;
		Scale .25;
		+BRIGHT
	}

	States
	{
	Spawn:
		ZBAL A 4 LIGHT("ZYKFLMW2") {
			A_SpawnProjectile("PoisonCloudUndead");
			A_SpawnProjectile("PoisonCloudUndead");
			A_SpawnProjectile("PoisonCloudUndead");
		}
		Loop;
	Death:
		ZBLX A 2 LIGHT("ZYKFLMW2") A_Explode(random(16,24), 128, 0, fulldamagedistance: 64);
		ZBLX BCDEFGHIJK 2 LIGHT("ZYKFLMW2");
		Stop;
	}
}

class RENemesis : NaziBoss
{
	Default
	{
		DamageFactor "UndeadPoison", 0;
		DamageFactor "UndeadPoisonAmbience", 0;
		Health 1600;
		Radius 64;
		Speed 6;
		Tag "$TAGNEMESIS";
		Base.BossIcon "BOSSICO2";
		+JUMPDOWN
	}

	States
	{
	Spawn:
		NEMS A 0 NoDelay {user_incombat = 1;}
		Goto Look;
	See:
		Goto See.Boss;
	Missile:
		NEMS A 0 A_Jump(100, "Missile2");
		NEMS FG 10;
		NEMS G 10 A_ArcProjectile("ZombieVomit", additionalHeight: 32);
		Goto See;
	Missile2:
		NEMS FG 10;
		NEMS G 10 A_SpawnProjectile("NemesisZyklonClouder");
		Goto See;
	Melee:
		NEMS HI 3;
		NEMS JK 3;
		Goto See;
	Pain:
		NEMS L 10;
		Goto See;
	Death: // Kneel after taking some damage
		NEMS O 0 {
			ACS_NamedExecute("City_Light_On", 0);
			return A_JumpIfInTargetInventory("NemesisDiesForGood", 1, "DeathForReal");
		}
		NEMS M 8 A_NoBlocking(false);
		NEMS N 8400; // Kneel for 4 minutes = 8400 tics, 3 seconds is easier to test with
		"####" "#" -1 { // This doesn't work if duration is 0 for some reason...
			// Keep previous target in "tracer" pointer to prevent it from
			// being lost, since actors lose their targets (and the lastEnemy)
			// when they are resurrected.
			A_RearrangePointers(AAPTR_NULL, newtracer: AAPTR_TARGET); 
			A_RaiseSelf(RF_NOCHECKPOSITION); // Doesn't work if duration is 0 for some reason.
		}
		Stop;
	DeathForReal:
		NEMS O 8 A_Scream;
		NEMS P 8;
		NEMS Q 8 A_NoBlocking;
		NEMS R 8;
		NEMS S -1;
		Stop;
	Raise:
		NEMS N 8 {
			bSolid = false;
			bShootable = false;
			ACS_NamedExecute("City_Light_Off", 0);
			A_RearrangePointers(AAPTR_TRACER); // Fetch target from "tracer" pointer.
		}
		NEMS M 8;
		NEMS A 0; // Set frame you see while disappearing
		"####" "#" 1 A_FadeOutJump(0.125, "Teleport");
		Wait;
	Teleport:
		"####" "#" 70 A_TeleportCloseTo(180, 384, "Reappear");
		Loop;
	Reappear:
		"####" "#" 0 {
			// Replace with jumpscare sound
			A_StartSound("misc/secret");
		}
		"####" "#" 1 {
			bSolid = true;
			bShootable = true;
			A_FadeInJump(0.125, "See");
		}
		Wait;
	}

	void A_FadeOutJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeOut(fadeAmount, flags);
		if (Alpha <= 0.0)
		{
			SetStateLabel(label);
		}
	}

	void A_FadeInJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeIn(fadeAmount, flags);
		if (Alpha >= 1.0)
		{
			SetStateLabel(label);
		}
	}

	// Checks whether the given angle is suitable for teleporting to. Returns the distance at the given angle which is suitable, or -1 if it is not suitable.
	double isAngleSuitable(double angle, double maxdistance, double checkIncrement = 16, double heightThreshold = 128)
	{
		double suitableDistance = -1;
		// Find closest wall
		SpotFinderTracer finder = new("SpotFinderTracer");
		Vector3 traceDirection = (AngleToVector(angle), 0);
		Vector3 traceOrigin = target.Pos;
		traceOrigin.Z += target.MaxStepHeight;
		finder.Trace(traceOrigin, target.CurSector, traceDirection, maxdistance, 0);
		// There is a wall blocking this angle!
		if (finder.hitWall)
		{
			maxdistance = finder.Results.Distance;
		}
		// Some setup
		Vector3 oldPosition = Pos;
		Sector targSec = Level.PointInSector(target.Pos.XY);
		double targFloorHeight = targSec.NextLowestFloorAt(target.Pos.X, target.Pos.Y, target.Pos.Z, 0, MaxStepHeight);
		double mindistance = Radius + Speed;
		// Check for a suitable spot to reappear at. Start at the furthest point, and close in to the target's position.
		for (
			double checkDistance = maxdistance;
			checkDistance > mindistance;
			checkDistance -= checkIncrement
		){
			Vector2 secCheckSpot = target.Vec2Angle(checkDistance, angle);
			Sector sec = Level.PointInSector(secCheckSpot);
			Vector3 checkSpot = target.Vec3Angle(checkDistance, angle);
			// Ensure Nemesis doesn't teleport into midair
			double closestFloorHeight = sec.NextLowestFloorAt(checkSpot.X, checkSpot.Y, checkSpot.Z, 0, MaxStepHeight);
			if ((targFloorHeight - closestFloorHeight) > MaxDropoffHeight)
			{
				continue;
			}
			/*
			// I don't know for sure, but this code might cause a bad
			// performance hit, and it's not even finished, so I'm leaving it
			// commented out for now, unless it's really needed.
			// For good measure - ensure he doesn't get stuck on an edge.
			BlockLinesIterator iter = BlockLinesIterator.CreateFromPos(checkSpot.X, checkSpot.Y, checkSpot.Z, MaxDropoffHeight, Radius + Speed, sec);
			bool onLedge = false;
			while (iter.Next())
			{
				if (!(iter.CurLine.flags & Line.ML_TWOSIDED))
				{
					continue;
				}
				Sector otherSector = iter.CurLine.frontsector;
				if (iter.CurLine.frontsector == sec)
				{
					otherSector = iter.CurLine.backsector;
				}
				if (otherSector.floorplane.ZatPoint(checkSpot.XY) > sec.floorplane.ZatPoint(checkSpot.XY))
				{
					continue;
				}
				double lowerFloor = otherSector.NextLowestFloorAt(checkSpot.X, checkSpot.Y, checkSpot.Z, 0, MaxStepHeight);
			}
			if (onLedge)
			{
				continue;
			}
			*/
			// Console.Printf("checkSpot: %.3f %.3f %.3f", checkSpot);
			SetOrigin(checkSpot, false);
			if (TestMobjLocation())
			{
				suitableDistance = checkDistance;
				break;
			}
		}
		SetOrigin(oldPosition, false);
		return suitableDistance;
	}

	State A_TeleportCloseTo(double preferredAngle = 180, double maxdistance = 384, StateLabel toJumpTo = null)
	{
		State appearState = FindState(toJumpTo, true);
		if (!target) {return appearState;}
		preferredAngle = target.Angle + preferredAngle;
		double suitableDistance = -1;
		double traceAngle = 0;
		for (double angleOffset = 0; angleOffset < 180; angleOffset += 22.5)
		{
			traceAngle = preferredAngle + angleOffset;
			suitableDistance = isAngleSuitable(traceAngle, maxdistance);
			if (suitableDistance > -1)
			{
				break;
			}
			// Check in the other direction
			traceAngle = preferredAngle - angleOffset;
			suitableDistance = isAngleSuitable(traceAngle, maxdistance);
			if (suitableDistance > -1)
			{
				break;
			}
		}
		// Console.Printf("suitableDistance: %.3f", suitableDistance);
		if (suitableDistance == -1)
		{
			return null;
		}
		SetOrigin(target.Vec3Angle(suitableDistance, traceAngle), false);
		// Get him un-stuck from the ledge, if any.
		Thrust(Speed, traceAngle + 180);
		return appearState;
	}
}

class NemesisDiesForGood : Inventory {
	Default
	{
		Inventory.MaxAmount 1;
	}
}