/*
 * Copyright (c) 2020 Talon1024
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class SpotFinderTracer : LineTracer
{
	// Set by the callback
	bool hitWall;

	override ETraceStatus TraceCallback()
	{
		if (Results.HitType == TRACE_HitFloor || Results.HitType == TRACE_HitCeiling)
		{
			hitWall = true;
			return TRACE_Stop;
		}
		else if (Results.HitType == TRACE_HitWall)
		{
			// Walls need further examination
			if (Results.Tier != TIER_Middle)
			{
				hitWall = true;
				return TRACE_Stop;
			}
			else
			{
				if (!(Results.HitLine.flags & Line.ML_TWOSIDED))
				{
					// Not a two-sided wall
					hitWall = true;
					return TRACE_Stop;
				}
				else
				{
					// Two-sided wall
					if (Results.HitLine.flags & Line.ML_BLOCKING)
					{
						hitWall = true;
						return TRACE_Stop;
					}
				}
			}
		}
		return TRACE_Skip;
	}
}

class RENemesis : NaziBoss
{
	Default
	{
		Health 300;
		Speed 6;
		Tag "TAGNEMESIS";
		Base.BossIcon "BOSSICO2";
		+JUMPDOWN
	}

	States
	{
	Spawn:
		NEMS A 0 NoDelay {user_incombat = 1;}
		Goto Look;
	See:
		Goto See.Boss;
	Missile:
		NEMS FG 10;
		NEMS G 10 A_ArcProjectile("ZombieVomit", additionalHeight: 32);
		Goto See;
	Melee:
		NEMS HI 3;
		NEMS JK 3;
		Goto See;
	Pain:
		NEMS L 10;
		Goto See;
	Death:
		NEMS M 8 A_Scream;
		NEMS NOP 8;
		NEMS Q 8 A_NoBlocking;
		NEMS R 8;
		NEMS S 105; // Use 10500 = 5 minutes for the final enemy, 3 seconds is easier to test with.
		NEMS S -1 {
			// Keep previous target in "tracer" pointer to prevent it from
			// being lost, since actors lose their targets (and the lastEnemy)
			// when they are resurrected.
			A_RearrangePointers(AAPTR_NULL, newtracer: AAPTR_TARGET); 
			A_RaiseSelf(RF_NOCHECKPOSITION); // Doesn't work if duration is 0 for some reason.
		}
		Stop;
	Raise:
		NEMS S 8 {
			bSolid = false;
			bShootable = false;
			A_RearrangePointers(AAPTR_TRACER); // Fetch target from "tracer" pointer.
		}
		NEMS RQPONML 8;
		NEMS A 0; // Set frame you see while disappearing
		"####" "#" 1 A_FadeOutJump(0.125, "Teleport");
		Wait;
	Teleport:
		"####" "#" 70 A_TeleportCloseTo(180, 384, "Reappear");
		Loop;
	Reappear:
		"####" "#" 1 {
			bSolid = true;
			bShootable = true;
			A_FadeInJump(0.125, "See");
		}
		Wait;
	}

	void A_FadeOutJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeOut(fadeAmount, flags);
		if (Alpha <= 0.0)
		{
			SetStateLabel(label);
		}
	}

	void A_FadeInJump(double fadeAmount, statelabel label, int flags = FTF_CLAMP)
	{
		A_FadeIn(fadeAmount, flags);
		if (Alpha >= 1.0)
		{
			SetStateLabel(label);
		}
	}

	// Checks whether the given angle is suitable for teleporting to. Returns the distance at the given angle which is suitable, or -1 if it is not suitable.
	double isAngleSuitable(double angle, double maxdistance, double checkIncrement = 16, double heightThreshold = 128)
	{
		double suitableDistance = -1;
		// Find closest wall
		SpotFinderTracer finder = new("SpotFinderTracer");
		Vector3 traceDirection = (AngleToVector(angle), 0);
		Vector3 traceOrigin = target.Pos;
		traceOrigin.Z += target.MaxStepHeight;
		finder.Trace(traceOrigin, target.CurSector, traceDirection, maxdistance, 0);
		// There is a wall blocking this angle!
		if (finder.hitWall)
		{
			maxdistance = finder.Results.Distance;
		}
		// Some setup
		Vector3 oldPosition = Pos;
		Sector targSec = Level.PointInSector(target.Pos.XY);
		double targFloorHeight = targSec.NextLowestFloorAt(target.Pos.X, target.Pos.Y, target.Pos.Z, 0, MaxStepHeight);
		double mindistance = Radius + Speed;
		// Check for a suitable spot to reappear at. Start at the furthest point, and close in to the target's position.
		for (
			double checkDistance = maxdistance;
			checkDistance > mindistance;
			checkDistance -= checkIncrement
		){
			Vector2 secCheckSpot = target.Vec2Angle(checkDistance, angle);
			Sector sec = Level.PointInSector(secCheckSpot);
			Vector3 checkSpot = target.Vec3Angle(checkDistance, angle);
			// Ensure Nemesis doesn't teleport into midair
			double closestFloorHeight = sec.NextLowestFloorAt(checkSpot.X, checkSpot.Y, checkSpot.Z, 0, MaxStepHeight);
			if ((targFloorHeight - closestFloorHeight) > heightThreshold)
			{
				continue;
			}
			/*
			// I don't know for sure, but this code might cause a bad
			// performance hit, and it's not even finished, so I'm leaving it
			// commented out for now, unless it's really needed.
			// For good measure - ensure he doesn't get stuck on an edge.
			BlockLinesIterator iter = BlockLinesIterator.CreateFromPos(checkSpot.X, checkSpot.Y, checkSpot.Z, heightThreshold, Radius + Speed, sec);
			bool onLedge = false;
			while (iter.Next())
			{
				if (!(iter.CurLine.flags & Line.ML_TWOSIDED))
				{
					continue;
				}
				Sector otherSector = iter.CurLine.frontsector;
				if (iter.CurLine.frontsector == sec)
				{
					otherSector = iter.CurLine.backsector;
				}
				if (otherSector.floorplane.ZatPoint(checkSpot.XY) > sec.floorplane.ZatPoint(checkSpot.XY))
				{
					continue;
				}
				double lowerFloor = otherSector.NextLowestFloorAt(checkSpot.X, checkSpot.Y, checkSpot.Z, 0, MaxStepHeight);
			}
			if (onLedge)
			{
				continue;
			}
			*/
			// Console.Printf("checkSpot: %.3f %.3f %.3f", checkSpot);
			SetOrigin(checkSpot, false);
			if (TestMobjLocation())
			{
				suitableDistance = checkDistance;
				break;
			}
		}
		SetOrigin(oldPosition, false);
		return suitableDistance;
	}

	State A_TeleportCloseTo(double preferredAngle = 180, double maxdistance = 384, StateLabel toJumpTo = null)
	{
		State appearState = FindState(toJumpTo, true);
		if (!target) {return appearState;}
		preferredAngle = target.Angle + preferredAngle;
		double suitableDistance = -1;
		double traceAngle = 0;
		for (double angleOffset = 0; angleOffset < 180; angleOffset += 22.5)
		{
			traceAngle = preferredAngle + angleOffset;
			suitableDistance = isAngleSuitable(traceAngle, maxdistance);
			if (suitableDistance > -1)
			{
				break;
			}
			// Check in the other direction
			traceAngle = preferredAngle - angleOffset;
			suitableDistance = isAngleSuitable(traceAngle, maxdistance);
			if (suitableDistance > -1)
			{
				break;
			}
		}
		// Console.Printf("suitableDistance: %.3f", suitableDistance);
		if (suitableDistance == -1)
		{
			return null;
		}
		SetOrigin(target.Vec3Angle(suitableDistance, traceAngle), false);
		// Get him un-stuck from the ledge, if any.
		Thrust(Speed, traceAngle + 180);
		return appearState;
	}
}