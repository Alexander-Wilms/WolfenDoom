#include "scripts/actors/effects/ash.txt"
#include "scripts/actors/effects/bubbles.txt"
#include "scripts/actors/effects/cinder.txt"
#include "scripts/actors/effects/clouds.txt"
#include "scripts/actors/effects/confetti.txt"
#include "scripts/actors/effects/fire.txt"
#include "scripts/actors/effects/laser.txt"
#include "scripts/actors/effects/leaves.txt"
#include "scripts/actors/effects/miscellaneous.txt"
#include "scripts/actors/effects/rain.txt"
#include "scripts/actors/effects/smoke.txt"
#include "scripts/actors/effects/snow.txt"
#include "scripts/actors/effects/sparks.txt"
#include "scripts/actors/effects/starparticles.txt"
#include "scripts/actors/effects/steam.txt"
#include "scripts/actors/effects/torches.txt"
#include "scripts/actors/effects/grass.txt"
#include "scripts/actors/effects/creepy.txt"

class EffectInfo // Should just be a struct, but we can't use structs in dynamic arrays...
{
	Actor effect;
	Class<actor> type;
	Vector3 position;
	double angle, pitch, roll;
	Vector2 scale;
	Actor master, target, tracer;
	int SpawnFlags;
	int args[5];
	int tid;
	bool dormant;
	bool ingame;
	double range;
	SpriteID sprite;
	uint8 frame;
	State curstate;
	bool wasculled;
	double radius, height;
	bool bflatsprite;
	bool bspecial;
	bool bsolid;
	bool bshootable;
}

// Effects get tracked in a dynamic array and culled when not in range of a player, then respawned when needed
class EffectsManager : Thinker
{
	Array<EffectInfo> effects;
	int interval;

	const cycletime = 35;

	static EffectsManager GetManager()
	{
		ThinkerIterator it = ThinkerIterator.Create("EffectsManager", Thinker.STAT_Default);
		EffectsManager manager = EffectsManager(it.Next());

		if (!manager) { manager = new("EffectsManager"); }

		return manager;
	}

	static void Add(Actor effect, double range = -1, bool force = false)
	{
		if (!effect) { return; }
		if (!force)
		{
			if (effect.tid || effect.master) { return; } // Don't add effects with a tid or a master, because we can't guarantee they'll be spawned back in when they are activated/deactivated
			if (!effect.bNoDamage && effect.bSolid && !effect.bNoInteraction) { return; } // Only add non-solid or non-interactive objects
		}

		EffectsManager manager = EffectsManager.GetManager();
		if (!manager) { return; }

		manager.AddEffect(effect, range);
	}

	static void Remove(Actor effect)
	{
		if (!effect) { return; }

		EffectsManager manager = EffectsManager.GetManager();
		if (!manager) { return; }


		manager.RemoveEffect(effect);
	}

	uint FindEffect(Actor effect)
	{
		for (int i = 0; i < effects.Size(); i++)
		{
			if (effects[i] && effects[i].ingame && effects[i].effect == effect) { return i; }
		}
		return effects.Size();
	}

	void AddEffect(Actor effect, double range = -1)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) // Only add it if it's not already there somehow.
		{
			EffectInfo this = New("EffectInfo");

			this.effect = effect;
			this.type = effect.GetClass();
			this.ingame = true;

			SaveEffectInfo(effect, this, range);

			effects.Push(this);
		}
		else // Otherwise just update what's there...
		{
			SaveEffectInfo(effect, effects[i], range);
		}
	}

	void SaveEffectInfo(Actor mo, EffectInfo info, double range = -1)
	{
		info.position = mo.pos;
		info.angle = mo.angle;
		info.pitch = mo.pitch;
		if (mo is "TreesBase")	// Trees have special pitch handling,
		{ 			// due to the fact they can be 2D as well.
			info.pitch = TreesBase(mo).origPitch;
		}
		info.roll = mo.roll;
		info.scale = mo.scale;
		info.master = mo.master;
		info.target = mo.target;
		info.tracer = mo.tracer;
		info.SpawnFlags = mo.SpawnFlags;

		for (int a = 0; a < 5; a++)
		{
			info.args[a] = mo.args[a];
		}

		info.tid = mo.tid;
		info.dormant = mo.bDormant;
		if (range >= 0) { info.range = range; }

		info.sprite = mo.sprite;
		info.frame = mo.frame;
		info.curstate = mo.CurState;

		if (mo is "Blocker")
		{
			info.radius = mo.radius;
			info.height = mo.height;
		}

		info.bflatsprite = mo.bFlatSprite;
		info.bspecial = mo.bSpecial;
		info.bsolid = mo.bSolid;
		info.bshootable = mo.bShootable;
	}

	void RemoveEffect(Actor effect)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) { return; }

		effects.Delete(i);
		effect.Destroy();
	}

	override void Tick()
	{
		CullEffects();
	}

	void CullEffects()
	{
		// Split up processing of the array across ticks to minimize single-tick think time
		interval = (interval + 1) % cycletime;
		double step = effects.Size() / double(cycletime);
		if (int(step) < step) { step = int(step) + 1; } 
		int start = interval * int(step);
		int end = min(effects.Size(), start + int(step));

		for (int i = start; i < end; i++)
		{
			if (i >= effects.Size()) { return; }
			if (!effects[i]) { continue; }

			if (effects[i].master && effects[i].master.bDormant)
			{
				effects.Delete(i); // If the master is deactivated, don't remember this effect anymore
				continue;
			}

			bool inrange = false;
			double dist, range;

			for (int p = 0; p < MAXPLAYERS && !inrange; p++)
			{
				if (!playeringame[p]) { continue; }

				Actor check = players[p].camera;
				if (!check) { check = players[p].mo; }
				if (!check) { continue; }

				range = effects[i].range <= 0 ? boa_sfxlod : effects[i].range;

				dist = (level.Vec3Diff(check.pos, effects[i].position)).length();
				if (dist < range) { inrange = true; }
			}

			if (inrange && !effects[i].ingame)
			{
				Actor effect = Actor.Spawn(effects[i].type, effects[i].position);
				if (effect)
				{
					effect.angle = effects[i].angle;
					effect.pitch = effects[i].pitch;
					effect.roll = effects[i].roll;
					effect.scale = effects[i].scale;
					effect.master = effects[i].master;
					effect.target = effects[i].target;
					effect.tracer = effects[i].tracer;
					effect.SpawnFlags = effects[i].SpawnFlags;
					effect.bDormant = effects[i].dormant;

					for (int a = 0; a < 5; a++)
					{
						effect.args[a] = effects[i].args[a];
					}

					effect.ChangeTID(effects[i].tid);
					if (effect.SpawnFlags & MTF_DORMANT || effects[i].dormant) { effect.SetStateLabel("Inactive"); }

					effect.sprite = effects[i].sprite;
					effect.frame = effects[i].frame;
					if (effects[i].curstate) { effect.SetState(effects[i].curstate); }

					if (effect is "Blocker") { effect.A_SetSize(effects[i].radius, effects[i].height); }

					effect.bFlatSprite = effects[i].bflatsprite;
					effect.bSpecial = effects[i].bspecial;
					effect.bSolid = effects[i].bsolid;
					effect.bShootable = effects[i].bshootable;

					effects[i].effect = effect;
					effects[i].ingame = true;
 
					if (effect is "CullActorBase") { CullActorBase(effect).wasculled = true; }
				}
			}
			else if (!inrange && effects[i].effect && !effects[i].effect.bDormant)
			{
				if (effects[i].effect is "CullActorBase" && (CullActorBase(effects[i].effect).targetalpha != -1 || effects[i].effect.health <= 0))
				{
					if (dist > range * 2) { CullActorBase(effects[i].effect).targetalpha = -1; }
					else { CullActorBase(effects[i].effect).targetalpha = GetDistanceAlpha(effects[i].effect, dist, range); }
				}
				else if (effects[i].effect.health <= 0) // Don't cull destroyed actors
				{
					effects.Delete(i); // ...and stop tracking them
				}
				else
				{
					Actor effect = effects[i].effect;

					if (effect is "CullActorBase") { effects[i].wasculled = true; }

					SaveEffectInfo(effect, effects[i], range);

					effects[i].effect.A_RemoveChildren(TRUE, RMVF_MISC);

					state FadeState = effects[i].effect.FindState("Fade");
					if (effects[i].effect.alpha > 0 && level.time > 35 && FadeState) { effects[i].effect.SetState(FadeState); }
					else {
						effects[i].effect = null;
						effect.Destroy();
						effect = null;
						effects[i].ingame = false;
					}
				}
			}
			else if (effects[i].effect && effects[i].effect is "CullActorBase") { CullActorBase(effects[i].effect).targetalpha = GetDistanceAlpha(effects[i].effect, dist, range); }
		}

		effects.ShrinkToFit();
	}

	static double GetDistanceAlpha(Actor effect, double dist, double range)
	{
		if (!effect) { return 0; }

		double ramp = 512;
		double rampdist = dist - (range - ramp);

		double alpha = 1.0 - clamp(rampdist / ramp, 0.0, 1.0);

		return effect.Default.alpha * alpha;
	}
}

class EffectSpawner : SwitchableDecoration
{
	ParticleManager manager;
	transient CVar switchcvar;
	String switchvar;
	int range;
	bool user_unmanaged;

	int flags;

	FlagDef AllowTickDelay:flags, 0;
	FlagDef DontCull:flags, 1;
	FlagDef DoActivation:flags, 2;

	Property Range:range;
	Property SwitchVar:switchvar;

	Default
	{
		+EffectSpawner.DoActivation // Automatically activate/deactivate based on DORMANT flag by default
	}

	States
	{
		Spawn:
		Inactive:
			TNT1 A -1;
			Wait;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (switchvar.length()) { switchcvar = CVar.FindCVar(switchvar); }

		manager = ParticleManager.GetManager();
		if (!manager) { return; }

		if (user_unmanaged)
		{
			bDontCull = true;
			bAllowTickDelay = false;
		}

		if (range > 0 && !bDontCull) { EffectsManager.Add(self, range > 0 ? min(range, boa_sfxlod) : boa_sfxlod); }

		if (bDoActivation)
		{
			if (bDormant || SpawnFlags & MTF_DORMANT) { Deactivate(null); }
			else { Activate(null); }
		}

		tics += Random(0, 35);
	}

	override void Activate(Actor activator)
	{
		if (switchcvar && !switchcvar.GetBool()) { SetStateLabel("Inactive"); }
		else
		{
			bDormant = false;
			SetStateLabel("Active");
		}
	}

	override void Deactivate(Actor activator)
	{
		bDormant = true;
		SetStateLabel("Inactive");
	}

	virtual void SpawnEffect()
	{
		if (!bAllowTickDelay || !manager) { return; }

		tics += curState.tics + manager.tickdelay;
	}
}

class EffectBase : SimpleActor
{
	States
	{
		Inactive:
			"####" A 0 A_Jump(256, "Spawn");
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_sfxlod);
	}
}

class CullActorBase : Actor
{
	double targetalpha;
	bool wasculled;

	States
	{
		Inactive:
			"####" A 0 A_Jump(256, "Spawn");
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (wasculled)
		{
			if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
			alpha = 0;
		}

		targetalpha = -1;
	}

	override void Tick()
	{
		Super.Tick();

		if (targetalpha >= 0)
		{
			if (targetalpha > alpha)
			{
				alpha = min(targetalpha, alpha + 0.05);
				if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
			}
			else if (targetalpha < alpha)
			{
				alpha = max(targetalpha, alpha - 0.05);
				if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
			}
			else
			{
				if (targetalpha == Default.alpha) { RestoreRenderStyle(); }
				alpha = targetalpha;
				targetalpha = -1;
			}
		}
	}

	bool SpawnBlock(double x, double y, double z, double r = -1, double h = -1)
	{
		Actor block = Spawn("Blocker", pos + (RotateVector((x * scale.x, y * scale.x), angle), z * scale.y));

		if (block)
		{
			block.A_SetSize(r, h);
			block.tracer = self;
			
			return true;
		}

		return false;
	}
}

class GrassBase : CullActorBase
{
	class<Actor> fragments;

	Property Fragments:fragments;	

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_grasslod);
	}
}

class SceneryBase : CullActorBase
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_scenelod, true);
	}
}

class TreesBase : CullActorBase
{
	float origPitch;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		origPitch = pitch;
		EffectsManager.Add(self, boa_treeslod, true);
	}

	void A_3DPitchFix()
	{
		// If the player has 2D trees on, and turns them off during a mission...
		pitch = origPitch;
	}

	void A_2DPitchFix()
	{
		if (origPitch > 2 || origPitch < -2)
		{
			bFlatSprite = true;
			pitch = origPitch + 270;
		}
	}
}

class VolumetricBase : CullActorBase
{
	Default
	{
		//$Category Special Effects (BoA)
		//$Color 12
		//$Sprite VOLTA0
		DistanceCheck "boa_scenelod";
		Height 1;
		Radius 1;
		+NOBLOCKMAP
		+NOCLIP
		+NOGRAVITY
		+NOINTERACTION
		XScale 0.3;
		YScale 0.45;
		Alpha 0.4;
		RenderStyle "Add";
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_scenelod);
	}
}

class Blocker : CullActorBase
{
	Default
	{
		+ACTLIKEBRIDGE
		+BRIGHT
		+DONTTHRUST
		+NOBLOOD
		+NODAMAGE
		+NOGRAVITY
		+NOTAUTOAIMED
		+SOLID
		+SHOOTABLE
		+INVISIBLE // Comment out to see the blocks in game for debugging
		Painchance 255;
		Radius 8;
		Height 16;
		Species "Block";
		RenderStyle "Add";
		Alpha 0.95;
	}

	States
	{
		Spawn:
			UNKN A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (!wasculled && tracer) { A_SetSize(Radius * tracer.scale.x, Height * tracer.scale.y); }

		scale.x = Radius * 2.0;
		scale.y = Height * level.pixelStretch;

		alpha = Default.alpha;

		EffectsManager.Add(self, 256.0); // These are invisible, so only need to be spawned in when immediately near the player
	}
}

class ParticleBase : SimpleActor // Use for non-interactive effects actors only!
{
	int checktimer;
	int flags;

	FlagDef CHECKPOSITION:flags, 0;

	States
	{
		Fade:
			"####" "#" 1 A_FadeOut(0.1, FTF_REMOVE);
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		// Set the initial check at a random tick so they don't all check at once...
		checktimer = Random(0, 35);
	}

	override void Tick()
	{
		Super.Tick();

		if (bCheckPosition && checktimer-- <= 0)
		{
			// If it's outside the level, remove it
			if (!level.IsPointInLevel(pos)) { Destroy(); return; }

			checktimer = 35; // Check once every second.
		}
	}
}

class BloodBase : ParticleBase
{
	int timer;

	override void Tick()
	{
		Super.Tick();

		if (waterlevel == 3) // Blood that's underwater fades out and gets larger over time until it disappears
		{
			timer++;

			if (timer > 35)
			{
				A_FadeOut(0.05, FTF_REMOVE);
				scale *= 1.1;
			}
		}
	}
}