#include "scripts/actors/effects/ash.txt"
#include "scripts/actors/effects/bubbles.txt"
#include "scripts/actors/effects/cinder.txt"
#include "scripts/actors/effects/clouds.txt"
#include "scripts/actors/effects/confetti.txt"
#include "scripts/actors/effects/fire.txt"
#include "scripts/actors/effects/laser.txt"
#include "scripts/actors/effects/leaves.txt"
#include "scripts/actors/effects/miscellaneous.txt"
#include "scripts/actors/effects/rain.txt"
#include "scripts/actors/effects/smoke.txt"
#include "scripts/actors/effects/snow.txt"
#include "scripts/actors/effects/sparks.txt"
#include "scripts/actors/effects/starparticles.txt"
#include "scripts/actors/effects/steam.txt"
#include "scripts/actors/effects/torches.txt"
#include "scripts/actors/effects/grass.txt"

class EffectInfo // Should just be a struct, but we can't use structs in dynamic arrays...
{
	Actor effect;
	Class<actor> type;
	Vector3 position;
	double angle, pitch, roll;
	Vector2 scale;
	Actor master, target, tracer;
	int SpawnFlags;
	int args[5];
	int tid;
	bool dormant;
	bool ingame;
	double range;
}

// Effects get tracked in a dynamic array and culled when not in range of a player, then respawned when needed
class EffectsManager : Thinker
{
	Array<EffectInfo> effects;
	int interval;

	const cycletime = 35;

	static EffectsManager GetManager()
	{
		ThinkerIterator it = ThinkerIterator.Create("EffectsManager", Thinker.STAT_Default);
		EffectsManager manager = EffectsManager(it.Next());

		if (!manager) { manager = new("EffectsManager"); }

		return manager;
	}

	static void Add(Actor effect, double range = -1, bool force = false)
	{
		if (!effect) { return; }
		if (!force)
		{
			if (effect.tid || effect.master) { return; } // Don't add effects with a tid or a master, because we can't guarantee they'll be spawned back in when they are activated/deactivated
			if (!effect.bNoDamage && effect.bSolid && !effect.bNoInteraction) { return; } // Only add non-solid or non-interactive objects
		}

		EffectsManager manager = EffectsManager.GetManager();
		if (!manager) { return; }

		manager.AddEffect(effect, range);
	}

	static void Remove(Actor effect)
	{
		if (!effect) { return; }

		EffectsManager manager = EffectsManager.GetManager();
		if (!manager) { return; }


		manager.RemoveEffect(effect);
	}

	uint FindEffect(Actor effect)
	{
		for (int i = 0; i < effects.Size(); i++)
		{
			if (effects[i] && effects[i].ingame && effects[i].effect == effect) { return i; }
		}
		return effects.Size();
	}

	void AddEffect(Actor effect, double range = -1)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) // Only add it if it's not already there somehow.
		{
			EffectInfo this = New("EffectInfo");
			this.effect = effect;
			this.type = effect.GetClass();
			this.position = effect.pos;
			this.angle = effect.angle;
			this.pitch = effect.pitch;
			this.roll = effect.roll;
			this.scale = effect.scale;
			this.master = effect.master;
			this.target = effect.target;
			this.tracer = effect.tracer;
			this.SpawnFlags = effect.SpawnFlags;

			for (int a = 0; a < 5; a++)
			{
				this.args[a] = effect.args[a];
			}

			this.tid = effect.tid;
			this.dormant = effect.bDormant;
			this.range = range;
			this.ingame = true;

			effects.Push(this);
		}
		else // Otherwise just update what's there...
		{
			effects[i].position = effect.pos;
			effects[i].angle = effect.angle;
			effects[i].pitch = effect.pitch;
			effects[i].roll = effect.roll;
			effects[i].scale = effect.scale;
			effects[i].master = effect.master;
			effects[i].target = effect.target;
			effects[i].tracer = effect.tracer;
			effects[i].SpawnFlags = effect.SpawnFlags;

			for (int a = 0; a < 5; a++)
			{
				effects[i].args[a] = effect.args[a];
			}

			effects[i].tid = effect.tid;
			effects[i].dormant = effect.bDormant;
			effects[i].range = range;
		}
	}

	void RemoveEffect(Actor effect)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) { return; }

		effects.Delete(i);
		effect.Destroy();
	}

	override void Tick()
	{
		CullEffects();
	}

	void CullEffects()
	{
		// Split up processing of the array across ticks to minimize single-tick think time
		interval = (interval + 1) % cycletime;
		double step = effects.Size() / double(cycletime);
		if (int(step) < step) { step = int(step) + 1; } 
		int start = interval * int(step);
		int end = min(effects.Size(), start + int(step));

		for (int i = start; i < end; i++)
		{
			if (i >= effects.Size()) { return; }
			if (!effects[i]) { continue; }

			if (effects[i].master && effects[i].master.bDormant)
			{
				effects.Delete(i); // If the master is deactivated, don't remember this effect anymore
				continue;
			}

			bool inrange = false;
			double dist, range;

			for (int p = 0; p < MAXPLAYERS && !inrange; p++)
			{
				if (!playeringame[p]) { continue; }

				Actor check = players[p].camera;
				if (!check) { check = players[p].mo; }
				if (!check) { continue; }

				range = effects[i].range <= 0 ? boa_sfxlod : effects[i].range;

				dist = (level.Vec3Diff(check.pos, effects[i].position)).length();
				if (dist < range) { inrange = true; }
			}

			if (inrange && !effects[i].ingame)
			{
				Actor effect = Actor.Spawn(effects[i].type, effects[i].position);
				if (effect)
				{
					effect.angle = effects[i].angle;
					effect.pitch = effects[i].pitch;
					effect.roll = effects[i].roll;
					effect.scale = effects[i].scale;
					effect.master = effects[i].master;
					effect.target = effects[i].target;
					effect.tracer = effects[i].tracer;
					effect.SpawnFlags = effects[i].SpawnFlags;
					effect.bDormant = effects[i].dormant;

					for (int a = 0; a < 5; a++)
					{
						effect.args[a] = effects[i].args[a];
					}

					effect.ChangeTID(effects[i].tid);
					if (effect.SpawnFlags & MTF_DORMANT || effects[i].dormant) { effect.SetStateLabel("Inactive"); }

					effects[i].effect = effect;
					effects[i].ingame = true;
				}
			}
			else if (!inrange && effects[i].effect && !effects[i].effect.bDormant)
			{
				if (effects[i].effect is "CullActorBase" && (CullActorBase(effects[i].effect).targetalpha != -1 || effects[i].effect.health <= 0))
				{
					if (dist > range * 2) { CullActorBase(effects[i].effect).targetalpha = -1; }
					else { CullActorBase(effects[i].effect).targetalpha = GetDistanceAlpha(effects[i].effect, dist, range); }
				}
				else if (effects[i].effect.health <= 0) // Don't cull destroyed actors
				{
					effects.Delete(i); // ...and stop tracking them
				}
				else
				{
					effects[i].effect.A_RemoveChildren(TRUE, RMVF_MISC);

					state FadeState = effects[i].effect.FindState("Fade");

					if (effects[i].effect.alpha > 0 && level.time > 35 && FadeState) { effects[i].effect.SetState(FadeState); }
					else {
						Actor effect = effects[i].effect;
						effect.Destroy();
						effects[i].effect = null;
						effect = null;
						effects[i].ingame = false;
					}
				}
			}
			else if (effects[i].effect && effects[i].effect is "CullActorBase") { CullActorBase(effects[i].effect).targetalpha = GetDistanceAlpha(effects[i].effect, dist, range); }
		}

		effects.ShrinkToFit();
	}

	static double GetDistanceAlpha(Actor effect, double dist, double range)
	{
		if (!effect) { return 0; }

		double ramp = 512;
		double rampdist = dist - (range - ramp);

		double alpha = 1.0 - clamp(rampdist / ramp, 0.0, 1.0);

		return effect.Default.alpha * alpha;
	}
}

class EffectSpawner : SwitchableDecoration
{
	ParticleManager manager;
	transient CVar switchcvar;
	String switchvar;
	int range;

	int flags;

	FlagDef AllowTickDelay:flags, 0;
	FlagDef DontCull:flags, 1;

	Property Range:range;
	Property SwitchVar:switchvar;

	States
	{
		Spawn:
		Inactive:
			TNT1 A -1;
			Wait;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (switchvar.length()) { switchcvar = CVar.FindCVar(switchvar); }

		manager = ParticleManager.GetManager();
		if (!manager) { return; }

		if (range > 0 && !bDontCull) { EffectsManager.Add(self, range > 0 ? min(range, boa_sfxlod) : boa_sfxlod); }

		if (bDormant || SpawnFlags & MTF_DORMANT) { Deactivate(null); }
		else { Activate(null); }

		tics += Random(0, 35);
	}

	override void Activate(Actor activator)
	{
		if (switchcvar && !switchcvar.GetBool()) { SetStateLabel("Inactive"); }
		else
		{
			bDormant = false;
			SetStateLabel("Active");
		}
	}

	override void Deactivate(Actor activator)
	{
		bDormant = true;
		SetStateLabel("Inactive");
	}

	virtual void SpawnEffect()
	{
		if (!bAllowTickDelay || !manager) { return; }

		tics += curState.tics + manager.tickdelay;
	}
}

class EffectBase : SimpleActor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_sfxlod);
	}
}

class CullActorBase : Actor
{
	double targetalpha;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
		alpha = 0;
		targetalpha = -1;
	}

	override void Tick()
	{
		Super.Tick();

		if (targetalpha >= 0)
		{
			if (targetalpha > alpha)
			{
				alpha = min(targetalpha, alpha + 0.05);
				if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
			}
			else if (targetalpha < alpha)
			{
				alpha = max(targetalpha, alpha - 0.05);
				if (GetRenderStyle() == STYLE_Normal) { A_SetRenderStyle(alpha, STYLE_Translucent); }
			}
			else
			{
				if (targetalpha == Default.alpha) { RestoreRenderStyle(); }
				alpha = targetalpha;
				targetalpha = -1;
			}
		}
	}
}

class GrassBase : CullActorBase
{
	class<Actor> fragments;

	Property Fragments:fragments;	

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_grasslod);
	}
}

class SceneryBase : CullActorBase
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_scenelod, true);
	}
}

class TreesBase : CullActorBase
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_treeslod, true);
	}
}

class VolumetricBase : CullActorBase
{
	Default
	{
		//$Category Special Effects (BoA)
		//$Color 12
		//$Sprite "VOLTA0"
		DistanceCheck "boa_scenelod";
		Height 1;
		Radius 1;
		+NOBLOCKMAP
		+NOCLIP
		+NOGRAVITY
		+NOINTERACTION
		XScale 0.3;
		YScale 0.45;
		Alpha 0.4;
		RenderStyle "Add";
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, boa_scenelod);
	}
}

class ParticleBase : SimpleActor // Use for non-interactive effects actors only!
{
	int checktimer;
	int flags;

	FlagDef CHECKPOSITION:flags, 0;

	States
	{
		Fade:
			"####" "#" 1 A_FadeOut(0.1, FTF_REMOVE);
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		// Set the initial check at a random tick so they don't all check at once...
		checktimer = Random(0, 35);
	}

	override void Tick()
	{
		Super.Tick();

		if (bCheckPosition && checktimer-- <= 0)
		{
			// If it's outside the level, remove it
			if (!level.IsPointInLevel(pos)) { Destroy(); return; }

			checktimer = 35; // Check once every second.
		}
	}
}
